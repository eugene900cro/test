


   if(SpreadStop==false)
     {
      current_spread=(SymbolInfoDouble(Symbol(),SYMBOL_ASK)-SymbolInfoDouble(Symbol(),SYMBOL_BID))/Point*0.1;
     }
   if(current_spread > max_spread)
     {
      max_spread = current_spread;
     }
   if(current_spread< min_spread)
     {
      min_spread = current_spread;
     }
   if(min_spread==0)
     {
      min_spread=current_spread;
     }
   if(current_spread>=MaxSpread)
     {
      // CeaseTrading=true;
      SpreadStop=true;
     }

//+-------------------------------Minimum AccEquity stop -----------------------------------+


//***************************************
//   Dynamic Minimum Equity Protection   *
//***************************************
static double minAccEquity = 0;
static double peakEquity = 0;
static double initialDiff = 0;
static bool initialized = false;
static double lastMinAccEquity = 0;  // Za praćenje promjena
double Equity = AccountEquity();

// Provjera promjene MinAccEquity
if(lastMinAccEquity != MinAccEquity)
{
    initialized = false;  // Force reinitialization
    peakEquity = 0;      // Reset peak
    lastMinAccEquity = MinAccEquity;
  //  Print("MinAccEquity changed from ", lastMinAccEquity, " to ", MinAccEquity);
}

//Print("Start check - Equity:", Equity, " MinAccEquity setting:", MinAccEquity);

if(MinAccEquity > 0)
{
    // Prva inicijalizacija ili nakon promjene MinAccEquity
    if(!initialized || peakEquity == 0)
    {
        peakEquity = Equity;
        initialDiff = Equity - MinAccEquity;
        minAccEquity = MinAccEquity;
        initialized = true;
     //   Print("INITIALIZATION - Peak:", peakEquity, " minAccEquity:", minAccEquity, " Diff:", initialDiff);
    }
    
    // Ažuriranje peak-a i minAccEquity
    if(Equity > peakEquity)
    {
        peakEquity = Equity;
        minAccEquity = peakEquity - initialDiff;
     //   Print("NEW PEAK - Peak:", peakEquity, " Updated minAccEquity:", minAccEquity);
    }
    
 //   Print("STATUS - Current Equity:", Equity, " Current minAccEquity:", minAccEquity, " Peak:", peakEquity);
    
    // Provjera za zatvaranje
    if(Equity <= minAccEquity)
    {
       // Print("CLOSING POSITIONS - Equity below minimum!");
        CloseAllThisSymbolBuy();
        CloseAllThisSymbolSell();
        ClosePendingBuyLimit();
        ClosePendingSellLimit();
        ClosePendingBuyStop ();
        ClosePendingSellStop ();
        StopMinEquity = true;
        
        if(ObjectFind("LabelMinEQ") < 0)
        {
            CreateLabel("LabelMinEQ", CORNER_RIGHT_UPPER, 200, 100, 
                       "STOP by MIN ACC EQUITY: " + DoubleToString(minAccEquity, 2) + " $", 
                       20, clrRed);
        }
    }
}

// Reset stop flaga
if(StopMinEquity && Equity > minAccEquity)
{
    StopMinEquity = false;
    ObjectDelete("LabelMinEQ");
  //  Print("Reset StopMinEquity flag");
}

//************ Label Display
if(MinAccEquity > 0)
{
    color c13;
    static double StartEquty = AccountBalance();
    
    // Reset StartEquty kada se promijeni MinAccEquity
    if(!initialized)
    {
        StartEquty = AccountBalance();
    }
    
    if(minAccEquity > StartEquty) {c13 = Lime;} else {c13 = Red;}
    
    ObjectDelete("pmk__AccMinimum");
    if(ObjectFind("pmk__AccMinimum") != 0)
    {
        ObjectCreate("pmk__AccMinimum", OBJ_LABEL, 0, 0, 0);
        ObjectSet("pmk__AccMinimum", OBJPROP_CORNER, 3);
        ObjectSet("pmk__AccMinimum", OBJPROP_XDISTANCE, 10);
        ObjectSet("pmk__AccMinimum", OBJPROP_YDISTANCE, 80);
        ObjectSetText("pmk__AccMinimum", "" + "ActMinBalance" + " " + DoubleToStr(minAccEquity, 2) + "  ", 12, "Arial", c13);
    }
}

//-- Cleanup when MinAccEquity is 0
if(MinAccEquity == 0)
{
    if(ObjectFind("pmk__AccMinimum") == 0)
    {
        ObjectDelete("pmk__AccMinimum");
    }
    if(ObjectFind("LabelMinEQ") == 0)
    {
        ObjectDelete("LabelMinEQ");
    }
    initialized = false;  // Reset initialization for next time
    peakEquity = 0;      // Reset peak
}


//------------------------------------








 if(ManualButtons==false)
    {
    
    

    
    
    
    
//--------------------------------------------------------------------------------------------
//-----------------SWITCH--------TRADE ------TYPE---------------------------------------------
//--------------------------------------------------------------------------------------------
/*
switch (Trade_Type) {
    case 11:
        Trade_Type = 11;
        double pending_ProfitTarget = ProfitTarget;
        
        double totalProfit = BuyProfit + SellProfit;
        double lastOrderProfit = 0;
        int lastTicket = 0;
        
        // Variables to track price movement
        static double lastBuyPrice = 0;
        static double lastSellPrice = 0;
        
        // Variables to track highest buy and lowest sell prices
        static double highestBuyOrderPrice = 0;
        static double lowestSellOrderPrice = 0;
        
        // Variables for dynamic spacing - now separated for buy and sell
        static int currentBuySpacing = PendingSpacing;
        static int currentSellSpacing = PendingSpacing;
        
        // Provjera vremenskog ograničenja
        bool timeRestricted = IsTimeRestricted();
        bool hasOpenOrders = HasOpenOrders();
        
        // Ažuriraj prikaz poruke o ograničenju
        ManageTimeRestrictionDisplay(timeRestricted, hasOpenOrders);
        
        // Ako je vrijeme ograničeno i nema otvorenih naloga, ne otvaraj nove
        bool allowNewOrders = !(timeRestricted && !hasOpenOrders);
        
        // Provjera je li tržište u sideways stanju
        bool isSideways = IsSidewaysMarket();
       
        // Crtanje Range zone na grafikonu
        DrawRangeZone();
        
        // Varijable za granice sideways zone
        double upperRangeZone = 0;
        double lowerRangeZone = 0;
        
        // Dohvati granice sideways zone
        if (isSideways) {
            if(GlobalVariableCheck("RangeHigh")) {
                upperRangeZone = GlobalVariableGet("RangeHigh");
            }
            if(GlobalVariableCheck("RangeLow")) {
                lowerRangeZone = GlobalVariableGet("RangeLow");
            }
            
            if(upperRangeZone == 0 || lowerRangeZone == 0) {
                for(int obj = ObjectsTotal() - 1; obj >= 0; obj--) {
                    string objName = ObjectName(obj);
                    if(StringFind(objName, "RangeHigh") >= 0 && ObjectType(objName) == OBJ_HLINE) {
                        upperRangeZone = ObjectGet(objName, OBJPROP_PRICE1);
                    }
                    else if(StringFind(objName, "RangeLow") >= 0 && ObjectType(objName) == OBJ_HLINE) {
                        lowerRangeZone = ObjectGet(objName, OBJPROP_PRICE1);
                    }
                }
            }
            
            if(upperRangeZone == 0 || lowerRangeZone == 0) {
                upperRangeZone = iHigh(Symbol(), RangeTimeFrame, iHighest(Symbol(), RangeTimeFrame, MODE_HIGH, 20, 0));
                lowerRangeZone = iLow(Symbol(), RangeTimeFrame, iLowest(Symbol(), RangeTimeFrame, MODE_LOW, 20, 0));  
                
                upperRangeZone += 5 * Point;
                lowerRangeZone -= 5 * Point;
            }
            
        }
        
        // Check for triggered orders and adjust spacing accordingly
        for(int m = OrdersHistoryTotal()-1; m >= 0; m--) {
            if(OrderSelect(m, SELECT_BY_POS, MODE_HISTORY)) {
                if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderCloseTime() > LastActionTime) {
                    // If a buy stop was triggered (converted to buy)
                    if(OrderType() == OP_BUY && OrderComment() == "Follow") {
                        currentSellSpacing += 10; // Increase sell spacing when buy order is activated
                        Print("Buy order activated - Sell spacing increased to ", currentSellSpacing);
                    }
                    // If a sell stop was triggered (converted to sell)
                    else if(OrderType() == OP_SELL && OrderComment() == "Follow") {
                        currentBuySpacing += 10; // Increase buy spacing when sell order is activated
                        Print("Sell order activated - Buy spacing increased to ", currentBuySpacing);
                    }
                }
            }
        }
        
        // Find highest buy and lowest sell order prices
        highestBuyOrderPrice = 0;
        lowestSellOrderPrice = 0;
        
        for(int s = 0; s < OrdersTotal(); s++) {
            if(OrderSelect(s, SELECT_BY_POS, MODE_TRADES)) {
                if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                    if(OrderType() == OP_BUY || OrderType() == OP_BUYSTOP) {
                        double orderPrice = OrderType() == OP_BUY ? OrderOpenPrice() : OrderOpenPrice();
                        if(orderPrice > highestBuyOrderPrice || highestBuyOrderPrice == 0) {
                            highestBuyOrderPrice = orderPrice;
                        }
                    }
                    else if(OrderType() == OP_SELL || OrderType() == OP_SELLSTOP) {
                       orderPrice = OrderType() == OP_SELL ? OrderOpenPrice() : OrderOpenPrice();
                        if(orderPrice < lowestSellOrderPrice || lowestSellOrderPrice == 0) {
                            lowestSellOrderPrice = orderPrice;
                        }
                    }
                    
                    if(OrderTicket() > lastTicket) {
                        lastTicket = OrderTicket();
                        lastOrderProfit = OrderProfit();
                        
                        if(OrderType() == OP_BUY || OrderType() == OP_BUYSTOP) {
                            lastOrderType = 0;
                            if(OrderType() == OP_BUY) {
                                lastBuyPrice = OrderOpenPrice();
                            }
                        } 
                        else if(OrderType() == OP_SELL || OrderType() == OP_SELLSTOP) {
                            lastOrderType = 1;
                            if(OrderType() == OP_SELL) {
                                lastSellPrice = OrderOpenPrice();
                            }
                        }
                    }
                }
            }
        }
        
        // Inicijalno postavljanje naloga
        if((BuyOrders == 0 && SellOrders == 0 && OPBuyStop == 0 && OPSellStop == 0 && allowNewOrders) || 
           (BuyOrders == SellOrders && OPBuyStop == 0 && OPSellStop == 0)) {
            bool allowPendingBuy = true;
            bool allowPendingSell = true;
            
            // Reset spacing to default for initial orders
            currentBuySpacing = PendingSpacing;
            currentSellSpacing = PendingSpacing;
            
            if (!TradeLong || SessionTargetStop || StopMinEquity || SpreadStop || !allowNewOrders || isSideways) {
                allowPendingBuy = false;
            }
            if (!TradeShort || SessionTargetStop || StopMinEquity || SpreadStop || !allowNewOrders || isSideways) {
                allowPendingSell = false;
            }
            
            if(allowPendingSell) {
                int pendingSellOrder = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, Bid - currentSellSpacing * Point, 3, 0, 0, "Initial", MagicNumber, 0, Red);
                if(pendingSellOrder > 0) {
                    lastSellPrice = Bid;
                    lowestSellOrderPrice = Bid - currentSellSpacing * Point;
                }
            }
            if(allowPendingBuy) {
                int pendingBuyOrder = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, Ask + currentBuySpacing * Point, 3, 0, 0, "Initial", MagicNumber, 0, Blue);
                if(pendingBuyOrder > 0) {
                    lastBuyPrice = Ask;
                    highestBuyOrderPrice = Ask + currentBuySpacing * Point;
                }
            }
            initialOrdersPlaced = true;
        }
        
        // Place new orders with dynamic spacing
        bool validRangeZone = (isSideways && upperRangeZone > 0 && lowerRangeZone > 0 && upperRangeZone > lowerRangeZone);
        
        if(allowNewOrders && !StopMinEquity && !SpreadStop && !SessionTargetStop) {
            // Check for new buy orders when price moves above highest buy order AND above upper range zone
            bool buyCondition = BuyOrders > 0 && Ask > highestBuyOrderPrice;
            if(validRangeZone) {
                buyCondition = buyCondition && Ask > upperRangeZone;
            }
            
            if(buyCondition && TradeLong) {
                // Use the current buy spacing directly without additional multipliers
                double newBuyPrice = Ask + currentBuySpacing * Point;
                int newBuyStop = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, newBuyPrice, 3, 0, 0, "Follow", MagicNumber, 0, Blue);
                if(newBuyStop > 0) {
                    highestBuyOrderPrice = newBuyPrice;
                    lastBuyPrice = Ask;
                    Print("New buy stop order placed with spacing: ", currentBuySpacing);
                }
                
                // Optional: Add counter sell order
                if(SellOrders < BuyOrders && TradeShort) {
                    // Just use currentSellSpacing directly without multiplier
                    double newSellPrice = Bid - currentSellSpacing * Point;
                    int counterSellStop = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, newSellPrice, 3, 0, 0, "Counter", MagicNumber, 0, Red);
                    if(counterSellStop > 0) {
                        if(lowestSellOrderPrice == 0 || newSellPrice < lowestSellOrderPrice) {
                            lowestSellOrderPrice = newSellPrice;
                        }
                        lastSellPrice = Bid;
                        Print("Counter sell stop order placed with spacing: ", currentSellSpacing);
                    }
                }
            }
            
            // Check for new sell orders when price moves below lowest sell order AND below lower range zone
            bool sellCondition = SellOrders > 0 && Bid < lowestSellOrderPrice;
            if(validRangeZone) {
                sellCondition = sellCondition && Bid < lowerRangeZone;
            }
            
            if(sellCondition && TradeShort) {
                // Use the current sell spacing directly
                 newSellPrice = Bid - currentSellSpacing * Point;
                int newSellStop = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, newSellPrice, 3, 0, 0, "Follow", MagicNumber, 0, Red);
                if(newSellStop > 0) {
                    lowestSellOrderPrice = newSellPrice;
                    lastSellPrice = Bid;
                    Print("New sell stop order placed with spacing: ", currentSellSpacing);
                }
                
                // Optional: Add counter buy order
                if(BuyOrders < SellOrders && TradeLong) {
                    // Just use currentBuySpacing directly
                   newBuyPrice = Ask + currentBuySpacing * Point;
                    int counterBuyStop = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, newBuyPrice, 3, 0, 0, "Counter", MagicNumber, 0, Blue);
                    if(counterBuyStop > 0) {
                        if(highestBuyOrderPrice == 0 || newBuyPrice > highestBuyOrderPrice) {
                            highestBuyOrderPrice = newBuyPrice;
                        }
                        lastBuyPrice = Ask;
                        Print("Counter buy stop order placed with spacing: ", currentBuySpacing);
                    }
                }
            }
        }
        
        // For larger quantities of pending orders use greater distances
        if(OPBuyStop > 10 || OPSellStop >= 10) {
            if(allowNewOrders && !StopMinEquity && !SpreadStop && !SessionTargetStop) {
                // For buy orders
                 buyCondition = BuyOrders > previousBuyOrders;
                if(validRangeZone) {
                    buyCondition = buyCondition && Ask > upperRangeZone;
                }
                
                if(buyCondition && TradeLong) {
                    // Use a base spacing for calculation so we maintain the proportions but with our dynamic spacing
                    int baseMultiplier = 3; // Original multiplier
                     newBuyPrice = highestBuyOrderPrice + currentBuySpacing * Point;
                    if(newBuyPrice > Ask) {
                       newBuyStop = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, newBuyPrice, 3, 0, 0, "Follow", MagicNumber, 0, Blue);
                        if(newBuyStop > 0) {
                            highestBuyOrderPrice = newBuyPrice;
                            lastBuyPrice = Ask;
                        }
                    }
                    
                    // Counter sell order
                    if(TradeShort) {
                        baseMultiplier = 1; // Just use the currentSellSpacing directly
                        newSellPrice = lowestSellOrderPrice - currentSellSpacing * Point;
                       counterSellStop = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, newSellPrice, 3, 0, 0, "Counter", MagicNumber, 0, Red);
                        if(counterSellStop > 0) {
                            lowestSellOrderPrice = newSellPrice;
                            lastSellPrice = Bid;
                        }
                    }
                }
                
                // For sell orders
                 sellCondition = SellOrders > previousSellOrders;
                if(validRangeZone) {
                    sellCondition = sellCondition && Bid < lowerRangeZone;
                }
                
                if(sellCondition && TradeShort) {
                    // Use the current sell spacing directly
                     newSellPrice = lowestSellOrderPrice - currentSellSpacing * Point;
                    if(newSellPrice < Bid) {
                        newSellStop = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, newSellPrice, 3, 0, 0, "Follow", MagicNumber, 0, Red);
                        if(newSellStop > 0) {
                            lowestSellOrderPrice = newSellPrice;
                            lastSellPrice = Bid;
                        }
                    }
                    
                    // Counter buy order
                    if(TradeLong) {
                        // Use the current buy spacing directly
                        newBuyPrice = highestBuyOrderPrice + currentBuySpacing * Point;
                        counterBuyStop = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, newBuyPrice, 3, 0, 0, "Counter", MagicNumber, 0, Blue);
                        if(counterBuyStop > 0) {
                            highestBuyOrderPrice = newBuyPrice;
                            lastBuyPrice = Ask;
                        }
                    }
                }
            }
        }
       
        // Zapamti trenutno stanje za sljedeću iteraciju
        previousBuyOrders = BuyOrders;
        previousSellOrders = SellOrders;
        
        // Profit target closing logic remains the same
        static bool singleOrderClosed = false;
        int totalActiveOrders = BuyOrders + SellOrders;
        
        if(totalProfit >= pending_ProfitTarget) {
            CloseOrdersOptimizedByProfit();
            ClosePendingBuyStop();
            ClosePendingSellStop();
            
            for(int attempts = 0; attempts < 5; attempts++) {
                bool allClosed = true;
                
                CloseOrdersOptimizedByProfit();
                ClosePendingBuyStop();
                ClosePendingSellStop();
                
                int checkBuyOrders = 0, checkSellOrders = 0, checkBuyStops = 0, checkSellStops = 0;
                
                for(int g = 0; g < OrdersTotal(); g++) {
                    if(OrderSelect(g, SELECT_BY_POS, MODE_TRADES)) {
                        if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                            if(OrderType() == OP_BUY) checkBuyOrders++;
                            else if(OrderType() == OP_SELL) checkSellOrders++;
                            else if(OrderType() == OP_BUYSTOP) checkBuyStops++;
                            else if(OrderType() == OP_SELLSTOP) checkSellStops++;
                        }
                    }
                }
                
                if(checkBuyOrders > 0 || checkSellOrders > 0 || checkBuyStops > 0 || checkSellStops > 0) {
                    allClosed = false;
                    int zatvaraj;  
                    for(int j = OrdersTotal() - 1; j >= 0; j--) {
                        if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES)) {
                            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                                if(OrderType() == OP_BUY) {
                                    zatvaraj = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_BID), 5, Blue);
                                }
                                else if(OrderType() == OP_SELL) {
                                    zatvaraj = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_ASK), 5, Red);
                                }
                                else if(OrderType() == OP_BUYSTOP || OrderType() == OP_SELLSTOP) {
                                    zatvaraj = OrderDelete(OrderTicket());
                                }
                            }
                        }
                    }
                } else {
                    break;
                }
            }
            
            singleOrderClosed = false;
            lastOrderType = -1;
            initialOrdersPlaced = false;
            lastBuyPrice = 0;
            lastSellPrice = 0;
            highestBuyOrderPrice = 0;
            lowestSellOrderPrice = 0;
            // Reset spacing when closing all orders
            currentBuySpacing = PendingSpacing;
            currentSellSpacing = PendingSpacing;
            
            Sleep(1000);
            
            if (!TradeLong || SessionTargetStop || StopMinEquity || SpreadStop || !allowNewOrders) {
                ForceInitialOrderPlacement();
            }
        }
        
        if(UseTrailingStop) {
            CheckAndApplyTrailingStop();
        }
        if(UseTrailingProfit) {
            CheckAndApplyTrailingProfit();
        }
        LastActionTime = Time[0];
        break;
}
*/  //-----------------
/*
switch (Trade_Type) {
    case 11:
        Trade_Type = 11;
        double pending_ProfitTarget = ProfitTarget;
        
        double totalProfit = BuyProfit + SellProfit;
        double lastOrderProfit = 0;
        int lastTicket = 0;
        
        // Variables to track price movement
        static double lastBuyPrice = 0;
        static double lastSellPrice = 0;
        
        // Variables to track highest buy and lowest sell prices
        static double highestBuyOrderPrice = 0;
        static double lowestSellOrderPrice = 0;
        
        // Variables for dynamic spacing - now separated for buy and sell
        static int currentBuySpacing = PendingSpacing;
        static int currentSellSpacing = PendingSpacing;
        
        // Static variable to track orders already processed
        static datetime lastProcessedTime = 0;
        
        // Provjera vremenskog ograničenja
        bool timeRestricted = IsTimeRestricted();
        bool hasOpenOrders = HasOpenOrders();
        
        // Ažuriraj prikaz poruke o ograničenju
        ManageTimeRestrictionDisplay(timeRestricted, hasOpenOrders);
        
        // Ako je vrijeme ograničeno i nema otvorenih naloga, ne otvaraj nove
        bool allowNewOrders = !(timeRestricted && !hasOpenOrders);
        
        // Provjera je li tržište u sideways stanju
        bool isSideways = IsSidewaysMarket();
       
        // Crtanje Range zone na grafikonu
        DrawRangeZone();
        
        // Varijable za granice sideways zone
        double upperRangeZone = 0;
        double lowerRangeZone = 0;
        
        // Dohvati granice sideways zone
        if (isSideways) {
            if(GlobalVariableCheck("RangeHigh")) {
                upperRangeZone = GlobalVariableGet("RangeHigh");
            }
            if(GlobalVariableCheck("RangeLow")) {
                lowerRangeZone = GlobalVariableGet("RangeLow");
            }
            
            if(upperRangeZone == 0 || lowerRangeZone == 0) {
                for(int obj = ObjectsTotal() - 1; obj >= 0; obj--) {
                    string objName = ObjectName(obj);
                    if(StringFind(objName, "RangeHigh") >= 0 && ObjectType(objName) == OBJ_HLINE) {
                        upperRangeZone = ObjectGet(objName, OBJPROP_PRICE1);
                    }
                    else if(StringFind(objName, "RangeLow") >= 0 && ObjectType(objName) == OBJ_HLINE) {
                        lowerRangeZone = ObjectGet(objName, OBJPROP_PRICE1);
                    }
                }
            }
        }
        
        // Check for triggered orders ONLY when we haven't processed them yet
        if (Time[0] > lastProcessedTime) {
            lastProcessedTime = Time[0]; // Update the time so we only process once per bar
            
            // Process historical orders to adjust spacing
            datetime latestOrderTime = 0;
            for(int m = OrdersHistoryTotal()-1; m >= 0; m--) {
                if(OrderSelect(m, SELECT_BY_POS, MODE_HISTORY)) {
                    if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderCloseTime() > LastActionTime) {
                        // Record the latest order time
                        if(OrderCloseTime() > latestOrderTime) {
                            latestOrderTime = OrderCloseTime();
                        }
                        
                        // If a buy stop was triggered (converted to buy)
                        if(OrderType() == OP_BUY && OrderComment() == "Follow") {
                            currentSellSpacing += 10; // Increase sell spacing when buy order is activated
                            Print("Buy order activated - Sell spacing increased to ", currentSellSpacing);
                        }
                        // If a sell stop was triggered (converted to sell)
                        else if(OrderType() == OP_SELL && OrderComment() == "Follow") {
                            currentBuySpacing += 10; // Increase buy spacing when sell order is activated
                            Print("Sell order activated - Buy spacing increased to ", currentBuySpacing);
                        }
                    }
                }
            }
    
            // Update LastActionTime to latest order time if any were found
            if(latestOrderTime > 0) {
                LastActionTime = latestOrderTime;
            }
        }
        
        // Find highest buy and lowest sell order prices
        highestBuyOrderPrice = 0;
        lowestSellOrderPrice = 0;
        
        for(int s = 0; s < OrdersTotal(); s++) {
            if(OrderSelect(s, SELECT_BY_POS, MODE_TRADES)) {
                if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                    if(OrderType() == OP_BUY || OrderType() == OP_BUYSTOP) {
                        double orderPrice = OrderType() == OP_BUY ? OrderOpenPrice() : OrderOpenPrice();
                        if(orderPrice > highestBuyOrderPrice || highestBuyOrderPrice == 0) {
                            highestBuyOrderPrice = orderPrice;
                        }
                    }
                    else if(OrderType() == OP_SELL || OrderType() == OP_SELLSTOP) {
                        orderPrice = OrderType() == OP_SELL ? OrderOpenPrice() : OrderOpenPrice();
                        if(orderPrice < lowestSellOrderPrice || lowestSellOrderPrice == 0) {
                            lowestSellOrderPrice = orderPrice;
                        }
                    }
                    
                    if(OrderTicket() > lastTicket) {
                        lastTicket = OrderTicket();
                        lastOrderProfit = OrderProfit();
                        
                        if(OrderType() == OP_BUY || OrderType() == OP_BUYSTOP) {
                            lastOrderType = 0;
                            if(OrderType() == OP_BUY) {
                                lastBuyPrice = OrderOpenPrice();
                            }
                        } 
                        else if(OrderType() == OP_SELL || OrderType() == OP_SELLSTOP) {
                            lastOrderType = 1;
                            if(OrderType() == OP_SELL) {
                                lastSellPrice = OrderOpenPrice();
                            }
                        }
                    }
                }
            }
        }
        
        // Count open orders and determine current spacing
        int actualBuyOrders = 0;
        int actualSellOrders = 0;
        
        for(int c = 0; c < OrdersTotal(); c++) {
            if(OrderSelect(c, SELECT_BY_POS, MODE_TRADES)) {
                if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                    if(OrderType() == OP_BUY) actualBuyOrders++;
                    else if(OrderType() == OP_SELL) actualSellOrders++;
                }
            }
        }
        
        // Additional debugging
        Print("Current Buy Spacing: ", currentBuySpacing, " | Current Sell Spacing: ", currentSellSpacing);
        Print("Actual Buy Orders: ", actualBuyOrders, " | Actual Sell Orders: ", actualSellOrders);
        
        // Inicijalno postavljanje naloga
        if((BuyOrders == 0 && SellOrders == 0 && OPBuyStop == 0 && OPSellStop == 0 && allowNewOrders) || 
           (BuyOrders == SellOrders && OPBuyStop == 0 && OPSellStop == 0)) {
            bool allowPendingBuy = true;
            bool allowPendingSell = true;
            
            // Reset spacing to default for initial orders
            currentBuySpacing = PendingSpacing;
            currentSellSpacing = PendingSpacing;
            
            if (!TradeLong || SessionTargetStop || StopMinEquity || SpreadStop || !allowNewOrders || isSideways) {
                allowPendingBuy = false;
            }
            if (!TradeShort || SessionTargetStop || StopMinEquity || SpreadStop || !allowNewOrders || isSideways) {
                allowPendingSell = false;
            }
            
            if(allowPendingSell) {
                int pendingSellOrder = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, Bid - currentSellSpacing * Point, 3, 0, 0, "Initial", MagicNumber, 0, Red);
                if(pendingSellOrder > 0) {
                    lastSellPrice = Bid;
                    lowestSellOrderPrice = Bid - currentSellSpacing * Point;
                }
            }
            if(allowPendingBuy) {
                int pendingBuyOrder = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, Ask + currentBuySpacing * Point, 3, 0, 0, "Initial", MagicNumber, 0, Blue);
                if(pendingBuyOrder > 0) {
                    lastBuyPrice = Ask;
                    highestBuyOrderPrice = Ask + currentBuySpacing * Point;
                }
            }
            initialOrdersPlaced = true;
        }
        
        // Place new orders with dynamic spacing
        bool validRangeZone = (isSideways && upperRangeZone > 0 && lowerRangeZone > 0 && upperRangeZone > lowerRangeZone);
        
        if(allowNewOrders && !StopMinEquity && !SpreadStop && !SessionTargetStop) {
            // Check for new buy orders when price moves above highest buy order AND above upper range zone
            bool buyCondition = BuyOrders > 0 && Ask > highestBuyOrderPrice;
            if(validRangeZone) {
                buyCondition = buyCondition && Ask > upperRangeZone;
            }
            
            if(buyCondition && TradeLong) {
                // Use the current buy spacing directly without additional multipliers
                double newBuyPrice = Ask + currentBuySpacing * Point;
                int newBuyStop = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, newBuyPrice, 3, 0, 0, "Follow", MagicNumber, 0, Blue);
                if(newBuyStop > 0) {
                    highestBuyOrderPrice = newBuyPrice;
                    lastBuyPrice = Ask;
                    Print("New buy stop order placed with spacing: ", currentBuySpacing);
                }
                
                // Optional: Add counter sell order
                if(SellOrders < BuyOrders && TradeShort) {
                    // Just use currentSellSpacing directly without multiplier
                    double newSellPrice = Bid - currentSellSpacing * Point;
                    int counterSellStop = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, newSellPrice, 3, 0, 0, "Counter", MagicNumber, 0, Red);
                    if(counterSellStop > 0) {
                        if(lowestSellOrderPrice == 0 || newSellPrice < lowestSellOrderPrice) {
                            lowestSellOrderPrice = newSellPrice;
                        }
                        lastSellPrice = Bid;
                        Print("Counter sell stop order placed with spacing: ", currentSellSpacing);
                    }
                }
            }
            
            // Check for new sell orders when price moves below lowest sell order AND below lower range zone
            bool sellCondition = SellOrders > 0 && Bid < lowestSellOrderPrice;
            if(validRangeZone) {
                sellCondition = sellCondition && Bid < lowerRangeZone;
            }
            
            if(sellCondition && TradeShort) {
                // Use the current sell spacing directly
                newSellPrice = Bid - currentSellSpacing * Point;
                int newSellStop = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, newSellPrice, 3, 0, 0, "Follow", MagicNumber, 0, Red);
                if(newSellStop > 0) {
                    lowestSellOrderPrice = newSellPrice;
                    lastSellPrice = Bid;
                    Print("New sell stop order placed with spacing: ", currentSellSpacing);
                }
                
                // Optional: Add counter buy order
                if(BuyOrders < SellOrders && TradeLong) {
                    // Just use currentBuySpacing directly
                     newBuyPrice = Ask + currentBuySpacing * Point;
                    int counterBuyStop = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, newBuyPrice, 3, 0, 0, "Counter", MagicNumber, 0, Blue);
                    if(counterBuyStop > 0) {
                        if(highestBuyOrderPrice == 0 || newBuyPrice > highestBuyOrderPrice) {
                            highestBuyOrderPrice = newBuyPrice;
                        }
                        lastBuyPrice = Ask;
                        Print("Counter buy stop order placed with spacing: ", currentBuySpacing);
                    }
                }
            }
        }
        
        
       
        // Zapamti trenutno stanje za sljedeću iteraciju
        previousBuyOrders = BuyOrders;
        previousSellOrders = SellOrders;
        
      
        // Profit target closing logic remains the same
        static bool singleOrderClosed = false;
        int totalActiveOrders = BuyOrders + SellOrders;
        
        if(totalProfit >= pending_ProfitTarget) {
            CloseOrdersOptimizedByProfit();
            ClosePendingBuyStop();
            ClosePendingSellStop();
            
            for(int attempts = 0; attempts < 5; attempts++) {
                bool allClosed = true;
                
                CloseOrdersOptimizedByProfit();
                ClosePendingBuyStop();
                ClosePendingSellStop();
                
                int checkBuyOrders = 0, checkSellOrders = 0, checkBuyStops = 0, checkSellStops = 0;
                
                for(int g = 0; g < OrdersTotal(); g++) {
                    if(OrderSelect(g, SELECT_BY_POS, MODE_TRADES)) {
                        if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                            if(OrderType() == OP_BUY) checkBuyOrders++;
                            else if(OrderType() == OP_SELL) checkSellOrders++;
                            else if(OrderType() == OP_BUYSTOP) checkBuyStops++;
                            else if(OrderType() == OP_SELLSTOP) checkSellStops++;
                        }
                    }
                }
                
            //-----------------------------
          // For larger quantities of pending orders use greater distances
        if(OPBuyStop > 5 || OPSellStop >= 5) {
            if(allowNewOrders && !StopMinEquity && !SpreadStop && !SessionTargetStop) {
                // For buy orders
                 buyCondition = BuyOrders > previousBuyOrders;
                if(validRangeZone) {
                    buyCondition = buyCondition && Ask > upperRangeZone;
                }
                
                if(buyCondition && TradeLong) {
                    // Use a base spacing for calculation so we maintain the proportions but with our dynamic spacing
                    int baseMultiplier = 3; // Original multiplier
                     newBuyPrice = highestBuyOrderPrice + currentBuySpacing * Point;
                    if(newBuyPrice > Ask) {
                       newBuyStop = OrderSend(Symbol(), OP_BUYSTOP, PendingLots*checkSellOrders, newBuyPrice, 3, 0, 0, "Follow", MagicNumber, 0, Blue);
                        if(newBuyStop > 0) {
                            highestBuyOrderPrice = newBuyPrice;
                            lastBuyPrice = Ask;
                        }
                    }
                    
                    // Counter sell order
                    if(TradeShort) {
                        baseMultiplier = 1; // Just use the currentSellSpacing directly
                        newSellPrice = lowestSellOrderPrice - currentSellSpacing * Point;
                       counterSellStop = OrderSend(Symbol(), OP_SELLSTOP, PendingLots*checkBuyOrders, newSellPrice, 3, 0, 0, "Counter", MagicNumber, 0, Red);
                        if(counterSellStop > 0) {
                            lowestSellOrderPrice = newSellPrice;
                            lastSellPrice = Bid;
                        }
                    }
                }
                
                // For sell orders
                 sellCondition = SellOrders > previousSellOrders;
                if(validRangeZone) {
                    sellCondition = sellCondition && Bid < lowerRangeZone;
                }
                
                if(sellCondition && TradeShort) {
                    // Use the current sell spacing directly
                     newSellPrice = lowestSellOrderPrice - currentSellSpacing * Point;
                    if(newSellPrice < Bid) {
                        newSellStop = OrderSend(Symbol(), OP_SELLSTOP, PendingLots*checkBuyOrders, newSellPrice, 3, 0, 0, "Follow", MagicNumber, 0, Red);
                        if(newSellStop > 0) {
                            lowestSellOrderPrice = newSellPrice;
                            lastSellPrice = Bid;
                        }
                    }
                    
                    // Counter buy order
                    if(TradeLong) {
                        // Use the current buy spacing directly
                        newBuyPrice = highestBuyOrderPrice + currentBuySpacing * Point;
                        counterBuyStop = OrderSend(Symbol(), OP_BUYSTOP, PendingLots*checkSellOrders, newBuyPrice, 3, 0, 0, "Counter", MagicNumber, 0, Blue);
                        if(counterBuyStop > 0) {
                            highestBuyOrderPrice = newBuyPrice;
                            lastBuyPrice = Ask;
                        }
                    }
                }
            }
        }
       
        //-----------------------------------     
                
                
                
                
                
                
                
                if(checkBuyOrders > 0 || checkSellOrders > 0 || checkBuyStops > 0 || checkSellStops > 0) {
                    allClosed = false;
                    int zatvaraj;  
                    for(int j = OrdersTotal() - 1; j >= 0; j--) {
                        if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES)) {
                            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                                if(OrderType() == OP_BUY) {
                                    zatvaraj = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_BID), 5, Blue);
                                }
                                else if(OrderType() == OP_SELL) {
                                    zatvaraj = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_ASK), 5, Red);
                                }
                                else if(OrderType() == OP_BUYSTOP || OrderType() == OP_SELLSTOP) {
                                    zatvaraj = OrderDelete(OrderTicket());
                                }
                            }
                        }
                    }
                } else {
                    break;
                }
            }
            
            singleOrderClosed = false;
            lastOrderType = -1;
            initialOrdersPlaced = false;
            lastBuyPrice = 0;
            lastSellPrice = 0;
            highestBuyOrderPrice = 0;
            lowestSellOrderPrice = 0;
            // Reset spacing when closing all orders
            currentBuySpacing = PendingSpacing;
            currentSellSpacing = PendingSpacing;
            
            Sleep(1000);
            
            if (!TradeLong || SessionTargetStop || StopMinEquity || SpreadStop || !allowNewOrders) {
                ForceInitialOrderPlacement();
            }
        }
        
        if(UseTrailingStop) {
            CheckAndApplyTrailingStop();
        }
        if(UseTrailingProfit) {
            CheckAndApplyTrailingProfit();
        }
        LastActionTime = Time[0];
        break;
}

*/
switch (Trade_Type) {
    case 11:
        Trade_Type = 11;
        double pending_ProfitTarget = ProfitTarget;
        
        double totalProfit = BuyProfit + SellProfit;
        double lastOrderProfit = 0;
        int lastTicket = 0;
        
        // Variables to track price movement
        static double lastBuyPrice = 0;
        static double lastSellPrice = 0;
        
        // Variables to track highest buy and lowest sell prices
        static double highestBuyOrderPrice = 0;
        static double lowestSellOrderPrice = 0;
        
        // Track if both initial orders have been triggered
        static bool bothInitialOrdersTriggered = false;
        
        // Variables for dynamic spacing - now separated for buy and sell
        int currentBuySpacing = PendingSpacing; 
        int currentSellSpacing = PendingSpacing;
        
        // Provjera vremenskog ograničenja
        bool timeRestricted = IsTimeRestricted();
        bool hasOpenOrders = HasOpenOrders();
        
        // Ažuriraj prikaz poruke o ograničenju
        ManageTimeRestrictionDisplay(timeRestricted, hasOpenOrders);
        
        // Ako je vrijeme ograničeno i nema otvorenih naloga, ne otvaraj nove
        bool allowNewOrders = !(timeRestricted && !hasOpenOrders);
        
        // Provjera je li tržište u sideways stanju
        bool isSideways = IsSidewaysMarket();
       
        // Crtanje Range zone na grafikonu
        DrawRangeZone();
        
        // Varijable za granice sideways zone
        double upperRangeZone = 0;
        double lowerRangeZone = 0;
        
        // Dohvati granice sideways zone
        if (isSideways) {
            if(GlobalVariableCheck("RangeHigh")) {
                upperRangeZone = GlobalVariableGet("RangeHigh");
            }
            if(GlobalVariableCheck("RangeLow")) {
                lowerRangeZone = GlobalVariableGet("RangeLow");
            }
            
            if(upperRangeZone == 0 || lowerRangeZone == 0) {
                for(int obj = ObjectsTotal() - 1; obj >= 0; obj--) {
                    string objName = ObjectName(obj);
                    if(StringFind(objName, "RangeHigh") >= 0 && ObjectType(objName) == OBJ_HLINE) {
                        upperRangeZone = ObjectGet(objName, OBJPROP_PRICE1);
                    }
                    else if(StringFind(objName, "RangeLow") >= 0 && ObjectType(objName) == OBJ_HLINE) {
                        lowerRangeZone = ObjectGet(objName, OBJPROP_PRICE1);
                    }
                }
            }
        }
        
        // Count open orders and calculate spacing based on current orders
        int actualBuyOrders = 0;
        int actualSellOrders = 0;
        int actualBuyStopOrders = 0;
        int actualSellStopOrders = 0;
        
        for(int c = 0; c < OrdersTotal(); c++) {
            if(OrderSelect(c, SELECT_BY_POS, MODE_TRADES)) {
                if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                    if(OrderType() == OP_BUY) actualBuyOrders++;
                    else if(OrderType() == OP_SELL) actualSellOrders++;
                    else if(OrderType() == OP_BUYSTOP) actualBuyStopOrders++;
                    else if(OrderType() == OP_SELLSTOP) actualSellStopOrders++;
                }
            }
        }
        
        // Check if both initial orders have been triggered
        if(!bothInitialOrdersTriggered && (actualBuyOrders > 0 || actualSellOrders > 0)) {
            if(actualBuyOrders > 0 && actualSellOrders > 0) {
                bothInitialOrdersTriggered = true;
            }
        }
        
        // Calculate spacing based on current orders
        currentSellSpacing = PendingSpacing + (actualBuyOrders * Spacing_Multiplayer);
        currentBuySpacing = PendingSpacing + (actualSellOrders * Spacing_Multiplayer);
        
        // Dodatni debugging
        Print("Current Buy Spacing: ", currentBuySpacing, " | Current Sell Spacing: ", currentSellSpacing);
        Print("Actual Buy Orders: ", actualBuyOrders, " | Actual Sell Orders: ", actualSellOrders);
        
        // Find highest buy and lowest sell order prices
        highestBuyOrderPrice = 0;
        lowestSellOrderPrice = 0;
        
        for(int s = 0; s < OrdersTotal(); s++) {
            if(OrderSelect(s, SELECT_BY_POS, MODE_TRADES)) {
                if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                    if(OrderType() == OP_BUY || OrderType() == OP_BUYSTOP) {
                        double orderPrice = OrderType() == OP_BUY ? OrderOpenPrice() : OrderOpenPrice();
                        if(orderPrice > highestBuyOrderPrice || highestBuyOrderPrice == 0) {
                            highestBuyOrderPrice = orderPrice;
                        }
                    }
                    else if(OrderType() == OP_SELL || OrderType() == OP_SELLSTOP) {
                        orderPrice = OrderType() == OP_SELL ? OrderOpenPrice() : OrderOpenPrice();
                        if(orderPrice < lowestSellOrderPrice || lowestSellOrderPrice == 0) {
                            lowestSellOrderPrice = orderPrice;
                        }
                    }
                    
                    if(OrderTicket() > lastTicket) {
                        lastTicket = OrderTicket();
                        lastOrderProfit = OrderProfit();
                        
                        if(OrderType() == OP_BUY || OrderType() == OP_BUYSTOP) {
                            lastOrderType = 0;
                            if(OrderType() == OP_BUY) {
                                lastBuyPrice = OrderOpenPrice();
                            }
                        } 
                        else if(OrderType() == OP_SELL || OrderType() == OP_SELLSTOP) {
                            lastOrderType = 1;
                            if(OrderType() == OP_SELL) {
                                lastSellPrice = OrderOpenPrice();
                            }
                        }
                    }
                }
            }
        }
        
        // Inicijalno postavljanje naloga (uvijek postavi oba pendinga)
        if((BuyOrders == 0 && SellOrders == 0 && OPBuyStop == 0 && OPSellStop == 0 && allowNewOrders) || 
           (BuyOrders == SellOrders && OPBuyStop == 0 && OPSellStop == 0)) {
            bool allowPendingBuy = true;
            bool allowPendingSell = true;
            
            // Reset bothInitialOrdersTriggered flag
            bothInitialOrdersTriggered = false;
            
            // Kod inicijalnih naloga koristimo osnovni spacing
            currentBuySpacing = PendingSpacing;
            currentSellSpacing = PendingSpacing;
            
            if (!TradeLong || SessionTargetStop || StopMinEquity || SpreadStop || !allowNewOrders || isSideways) {
                allowPendingBuy = false;
            }
            if (!TradeShort || SessionTargetStop || StopMinEquity || SpreadStop || !allowNewOrders || isSideways) {
                allowPendingSell = false;
            }
            
            if(allowPendingSell) {
                int pendingSellOrder = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, Bid - currentSellSpacing * Point, 3, 0, 0, "Initial", MagicNumber, 0, Red);
                if(pendingSellOrder > 0) {
                    lastSellPrice = Bid;
                    lowestSellOrderPrice = Bid - currentSellSpacing * Point;
                }
            }
            if(allowPendingBuy) {
                int pendingBuyOrder = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, Ask + currentBuySpacing * Point, 3, 0, 0, "Initial", MagicNumber, 0, Blue);
                if(pendingBuyOrder > 0) {
                    lastBuyPrice = Ask;
                    highestBuyOrderPrice = Ask + currentBuySpacing * Point;
                }
            }
            initialOrdersPlaced = true;
        }
        
        // Place new orders only after both initial orders have been triggered
        bool validRangeZone = (isSideways && upperRangeZone > 0 && lowerRangeZone > 0 && upperRangeZone > lowerRangeZone);
        
        if(allowNewOrders && !StopMinEquity && !SpreadStop && !SessionTargetStop && bothInitialOrdersTriggered) {
            // Determine which side is in profit
            bool buySideInProfit = BuyProfit > SellProfit;
            bool sellSideInProfit = SellProfit > BuyProfit;
            
            // Check for new buy orders when price moves above highest buy order AND above upper range zone
            bool buyCondition = BuyOrders > 0 && Ask > highestBuyOrderPrice;
            if(validRangeZone) {
                buyCondition = buyCondition && Ask > upperRangeZone;
            }
            
            // Only place new buy orders if buy side is in profit
            if(buyCondition && TradeLong && buySideInProfit) {
                double newBuyPrice = Ask + currentBuySpacing * Point;
                int newBuyStop = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, newBuyPrice, 3, 0, 0, "Follow", MagicNumber, 0, Blue);
                if(newBuyStop > 0) {
                    highestBuyOrderPrice = newBuyPrice;
                    lastBuyPrice = Ask;
                    Print("New buy stop order placed with spacing: ", currentBuySpacing);
                }
            }
            
            // Check for new sell orders when price moves below lowest sell order AND below lower range zone
            bool sellCondition = SellOrders > 0 && Bid < lowestSellOrderPrice;
            if(validRangeZone) {
                sellCondition = sellCondition && Bid < lowerRangeZone;
            }
            
            // Only place new sell orders if sell side is in profit
            if(sellCondition && TradeShort && sellSideInProfit) {
                double newSellPrice = Bid - currentSellSpacing * Point;
                int newSellStop = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, newSellPrice, 3, 0, 0, "Follow", MagicNumber, 0, Red);
                if(newSellStop > 0) {
                    lowestSellOrderPrice = newSellPrice;
                    lastSellPrice = Bid;
                    Print("New sell stop order placed with spacing: ", currentSellSpacing);
                }
            }
        }
        
        // Zapamti trenutno stanje za sljedeću iteraciju
        previousBuyOrders = BuyOrders;
        previousSellOrders = SellOrders;
        
        // Profit target closing logic remains the same
        static bool singleOrderClosed = false;
        int totalActiveOrders = BuyOrders + SellOrders;
        
        if(totalProfit >= pending_ProfitTarget) {
            CloseOrdersOptimizedByProfit();
            ClosePendingBuyStop();
            ClosePendingSellStop();
            
            for(int attempts = 0; attempts < 5; attempts++) {
                bool allClosed = true;
                
                CloseOrdersOptimizedByProfit();
                ClosePendingBuyStop();
                ClosePendingSellStop();
                
                int checkBuyOrders = 0, checkSellOrders = 0, checkBuyStops = 0, checkSellStops = 0;
                
                for(int g = 0; g < OrdersTotal(); g++) {
                    if(OrderSelect(g, SELECT_BY_POS, MODE_TRADES)) {
                        if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                            if(OrderType() == OP_BUY) checkBuyOrders++;
                            else if(OrderType() == OP_SELL) checkSellOrders++;
                            else if(OrderType() == OP_BUYSTOP) checkBuyStops++;
                            else if(OrderType() == OP_SELLSTOP) checkSellStops++;
                        }
                    }
                }
                
                if(checkBuyOrders > 0 || checkSellOrders > 0 || checkBuyStops > 0 || checkSellStops > 0) {
                    allClosed = false;
                    int zatvaraj;  
                    for(int j = OrdersTotal() - 1; j >= 0; j--) {
                        if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES)) {
                            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                                if(OrderType() == OP_BUY) {
                                    zatvaraj = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_BID), 5, Blue);
                                }
                                else if(OrderType() == OP_SELL) {
                                    zatvaraj = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_ASK), 5, Red);
                                }
                                else if(OrderType() == OP_BUYSTOP || OrderType() == OP_SELLSTOP) {
                                    zatvaraj = OrderDelete(OrderTicket());
                                }
                            }
                        }
                    }
                } else {
                    break;
                }
            }
            
            singleOrderClosed = false;
            lastOrderType = -1;
            initialOrdersPlaced = false;
            lastBuyPrice = 0;
            lastSellPrice = 0;
            highestBuyOrderPrice = 0;
            lowestSellOrderPrice = 0;
            bothInitialOrdersTriggered = false;
            
            Sleep(1000);
            
            if (!TradeLong || SessionTargetStop || StopMinEquity || SpreadStop || !allowNewOrders) {
                ForceInitialOrderPlacement();
            }
        }
        
        if(UseTrailingStop) {
            CheckAndApplyTrailingStop();
        }
        if(UseTrailingProfit) {
            CheckAndApplyTrailingProfit();
        }
        LastActionTime = Time[0];
        break;
}

   }//if manual butons==false
//-------------------------------------------------------------
    

//---------------------------end buy sell logic
   if(AccountMargin()!=0)
     {
      MarginPercent = MathRound((AccountEquity() / AccountMargin()) * 100);
     }

   if(LowMarginPercent > MarginPercent)
      LowMarginPercent = MarginPercent;
   if(AccountEquity() < LowEquity)
      LowEquity = AccountEquity();
   double BuySellProfit=BuyProfit+SellProfit;

   double buyLots=BuyLots;
   double sellLots=SellLots;

//-------------


   if(value_to_toggle==0)
     {
      FrameLB(4,130,20,430,430);//}//postavljenje back labela kod manual moda

      FrameLBS(2,90,180,620,180);//background black label za nuy sell buttons
      string k1 ="Buys"        "                      "+BuyOrders+"   ""    BuyStop: "+OPBuyStop+  "";
      string k2 ="BuyLots"     "                "+DoubleToStr(BuyLots,2)+"";
      string k3 ="BuysInProfit "              "  "+DoubleToStr(PosBuyProfit,2)+"";
      string k4 ="Highest Buy  "       " "+DoubleToStr(HighestBuy,Digits)+" #"+DoubleToStr(HighestBuyTicket,0)+"  Profit: "+DoubleToStr(HighestBuyProfit,2)+"";
      string k5 ="Lowest Buy   "       " "+DoubleToStr(LowestBuy,Digits)+" #"+DoubleToStr(LowestBuyTicket,0)+"  Profit: "+DoubleToStr(LowestBuyProfit,2)+"";
      string k6 ="Sells"       "                     "+SellOrders+"   ""    SellStop: "+OPSellStop+  "";
      string k7 ="SellLots"    "               "+DoubleToStr(SellLots,2)+"";
      string k8 ="SellsInProfit"              "   "+DoubleToStr(PosSellProfit,2)+"";
      string k9 ="Highest Sell"        "   "+DoubleToStr(HighestSell,Digits)+" #"+DoubleToStr(HighestSellTicket,0)+"  Profit: "+DoubleToStr(HighestSellProfit,2)+"";
      string k10 ="Lowest Sell  "          "  "+DoubleToStr(LowestSell,Digits)+" #"+DoubleToStr(LowestSellTicket,0)+"  Profit: "+DoubleToStr(LowestSellProfit,2)+"";
      string k11 ="BP+SP        "             "   "+DoubleToStr(PosSellProfit+PosBuyProfit,2)+"";
      string k12 ="BuyProfit    "             "    "+DoubleToStr(BuyProfit,2)+"";
      string k13 ="SellProfit    "             "    "+DoubleToStr(SellProfit,2)+"";


      Write1("pmk_17", 0, 0, 110, 30, k1, 9, "Vedrana", White);//bez ovoga ne prikazuje prvi red kada je backlabel na true a to sluzi da su candle iza labela
      Write1("pmk_1", 0, 0, 110, 30, k1, 9, "Vedrana", White);
      Write1("pmk_2", 0, 0, 110, 50, k2, 9, "Vedrana", Yellow);
      Write1("pmk_3", 0, 0, 110, 70, k12, 11, "Vedrana", DodgerBlue);
      Write1("pmk_4", 0, 0, 110, 90, k3, 11, "Vedrana", DodgerBlue);
      Write1("pmk_5", 0, 0, 110, 110, k4, 11, "Vedrana", DodgerBlue);
      Write1("pmk_6", 0, 0, 110, 130, k5, 11, "Vedrana", DodgerBlue);
      Write1("pmk_7", 0, 0, 110, 150, k6, 9, "Vedrana", White);
      Write1("pmk_8", 0, 0, 110, 170, k7, 9, "Vedrana", Yellow);
      Write1("pmk_9", 0, 0, 110, 190, k13, 11, "Vedrana", Red);
      Write1("pmk_10", 0, 0, 110, 210, k8, 11, "Vedrana", Red);
      Write1("pmk_11", 0, 0, 110, 230, k9, 11, "Vedrana", Red);
      Write1("pmk_12", 0, 0, 110, 250, k10, 11, "Vedrana", Red);
      Write1("pmk_13", 0, 0, 110, 270, k11, 11, "Vedrana", Orange);

     }//value to togle==0
//---------------------------------------------

//brisanje pozadinskog labela i vrjednosti kod auomatskog trejda
   if(value_to_toggle==1)
     {
      FrameLB(0,0,0,0,0);
      FrameLBS(0,0,0,0,0);
      Write1("pmk_17", 0, 0, 110, 30, "", 9, "Vedrana", White);
      Write1("pmk_1", 0, 0, 110, 30, "", 9, "Vedrana", White);
      Write1("pmk_2", 0, 0, 110, 50, "", 9, "Vedrana", Yellow);
      Write1("pmk_3", 0, 0, 110, 70, "", 11, "Vedrana", DodgerBlue);
      Write1("pmk_4", 0, 0, 110, 90, "", 11, "Vedrana", DodgerBlue);
      Write1("pmk_5", 0, 0, 110, 110, "", 11, "Vedrana", DodgerBlue);
      Write1("pmk_6", 0, 0, 110, 130, "", 9, "Vedrana", White);
      Write1("pmk_7", 0, 0, 110, 150, "", 9, "Vedrana", Yellow);
      Write1("pmk_8", 0, 0, 110, 170, "", 11, "Vedrana", Red);
      Write1("pmk_9", 0, 0, 110, 190, "", 11, "Vedrana", Red);
      Write1("pmk_10", 0, 0, 110, 210, "", 11, "Vedrana", Red);
      Write1("pmk_11", 0, 0, 110, 250, "", 11, "Vedrana", Orange);
      Write1("pmk_12", 0, 0, 110, 250, "", 11, "Vedrana", Red);
      Write1("pmk_13", 0, 0, 110, 270, "", 11, "Vedrana", Orange);
     }//if value to togle==1

//*******************************************************************************************************************
//*************************************************************
//za mod pending trad ako je auto  da se vidi broj naloga
//-------------***********************************************


   if(value_to_toggle==1&& Trade_Type==11)
     {
    FrameLB(4,130,20,430,430);//}//postavljenje back labela kod manual moda

    //  FrameLBS(2,90,180,620,180);//background black label za nuy sell buttons
      string k100 ="Buys"        "                      "+BuyOrders+"  Highest: "+MaxBuys+"";
      string k200 ="BuyLots"     "                "+DoubleToStr(BuyLots,2)+"";
      string k300 ="BuysInProfit "              "  "+DoubleToStr(PosBuyProfit,2)+"";
      string k400 ="BuyStop      "              "  "+OPBuyStop+"" ;
     // OPBuyStop==0 && OPSellStop==0
     // string k400 ="Highest Buy  "       " "+DoubleToStr(HighestBuy,Digits)+" #"+DoubleToStr(HighestBuyTicket,0)+"  Profit: "+DoubleToStr(HighestBuyProfit,2)+"";
     // string k500 ="Lowest Buy   "       " "+DoubleToStr(LowestBuy,Digits)+" #"+DoubleToStr(LowestBuyTicket,0)+"  Profit: "+DoubleToStr(LowestBuyProfit,2)+"";
      string k600 ="Sells"       "                     "+SellOrders+"  Highest: "+MaxSells+"";
      string k700 ="SellLots"    "               "+DoubleToStr(SellLots,2)+"";
      string k800 ="SellsInProfit"              "   "+DoubleToStr(PosSellProfit,2)+"";
      string k900 ="SellStop      "              "  "+OPSellStop+"" ;
    //  string k900 ="Highest Sell"        "   "+DoubleToStr(HighestSell,Digits)+" #"+DoubleToStr(HighestSellTicket,0)+"  Profit: "+DoubleToStr(HighestSellProfit,2)+"";
     // string k1000 ="Lowest Sell  "          "  "+DoubleToStr(LowestSell,Digits)+" #"+DoubleToStr(LowestSellTicket,0)+"  Profit: "+DoubleToStr(LowestSellProfit,2)+"";
      string k1100 ="BP+SP        "             "   "+DoubleToStr(PosSellProfit+PosBuyProfit,2)+"";
      string k1200 ="BuyProfit    "             "    "+DoubleToStr(BuyProfit,2)+"";
      string k1300 ="SellProfit    "             "    "+DoubleToStr(SellProfit,2)+"";


      Write1("pmk_17", 0, 0, 110, 30, k100, 9, "Vedrana", White);//bez ovoga ne prikazuje prvi red kada je backlabel na true a to sluzi da su candle iza labela
      Write1("pmk_1", 0, 0, 110, 30, k100, 9, "Vedrana", White);
      Write1("pmk_2", 0, 0, 110, 50, k200, 9, "Vedrana", Yellow);
      Write1("pmk_3", 0, 0, 110, 70, k1200, 11, "Vedrana", DodgerBlue);
      Write1("pmk_4", 0, 0, 110, 90, k300, 11, "Vedrana", DodgerBlue);
      Write1("pmk_5", 0, 0, 110, 110, k400, 11, "Vedrana", DodgerBlue);
     // Write1("pmk_6", 0, 0, 110, 130, k500, 11, "Vedrana", DodgerBlue);
      Write1("pmk_7", 0, 0, 110, 150, k600, 9, "Vedrana", White);
      Write1("pmk_8", 0, 0, 110, 170, k700, 9, "Vedrana", Yellow);
      Write1("pmk_9", 0, 0, 110, 190, k1300, 11, "Vedrana", Red);
      Write1("pmk_10", 0, 0, 110, 210, k800, 11, "Vedrana", Red);
      Write1("pmk_11", 0, 0, 110, 230, k900, 11, "Vedrana", Red);
    //  Write1("pmk_12", 0, 0, 110, 250, k1000, 11, "Vedrana", Red);
      Write1("pmk_13", 0, 0, 110, 270, k1100, 11, "Vedrana", Orange);

     }//value to togle==0
//---------------------------------------------
//brisanje pozadinskog labela i vrjednosti kod auomatskog trejda
   if(value_to_toggle==1&&  Trade_Type!=11)
     {
      FrameLB(0,0,0,0,0);
      FrameLBS(0,0,0,0,0);
      Write1("pmk_17", 0, 0, 110, 30, "", 9, "Vedrana", White);
      Write1("pmk_1", 0, 0, 110, 30, "", 9, "Vedrana", White);
      Write1("pmk_2", 0, 0, 110, 50, "", 9, "Vedrana", Yellow);
      Write1("pmk_3", 0, 0, 110, 70, "", 11, "Vedrana", DodgerBlue);
      Write1("pmk_4", 0, 0, 110, 90, "", 11, "Vedrana", DodgerBlue);
      Write1("pmk_5", 0, 0, 110, 110, "", 11, "Vedrana", DodgerBlue);
      Write1("pmk_6", 0, 0, 110, 130, "", 9, "Vedrana", White);
      Write1("pmk_7", 0, 0, 110, 150, "", 9, "Vedrana", Yellow);
      Write1("pmk_8", 0, 0, 110, 170, "", 11, "Vedrana", Red);
      Write1("pmk_9", 0, 0, 110, 190, "", 11, "Vedrana", Red);
      Write1("pmk_10", 0, 0, 110, 210, "", 11, "Vedrana", Red);
      Write1("pmk_11", 0, 0, 110, 250, "", 11, "Vedrana", Orange);
      Write1("pmk_12", 0, 0, 110, 250, "", 11, "Vedrana", Red);
      Write1("pmk_13", 0, 0, 110, 270, "", 11, "Vedrana", Orange);
     }//if value to togle==1

//*******************************************************************************************************************

//------------------------------------------ indikatori za rucni trejd
//--------------------------------------------------------------------
   if(RightSideLabel)
     {
      // -----------------Chard Profit-----------

      double SesProfit=SessionProfitC();
      string textChard;
      color cl2;
      double ChardProfit;
      ChardProfit=SesProfit;
      trenutniProfit=SesProfit;
      if(returnValueC ==0)
        {
         textChard = +ChardProfit+" $";
         cl2=Yellow;
        }
      if(returnValueC>0)
        {
         textChard = +ChardProfit+" $";
         cl2=Lime;
        }
      if(returnValueC<0)
        {
         textChard = +ChardProfit+" $";
         cl2= Red;
        }
        {
         ObjectDelete("pmk__CHprofit");
         if(ObjectFind("pmk__CHprofit")!=0)
           {
            ObjectCreate("pmk__CHprofit",OBJ_LABEL,0,0,0);
            ObjectSet("pmk__CHprofit",OBJPROP_CORNER,3);//4
            ObjectSet("pmk__CHprofit",OBJPROP_XDISTANCE,10);//200
            ObjectSet("pmk__CHprofit",OBJPROP_YDISTANCE,60);//105
            ObjectSetText("pmk__CHprofit",""+Symbol()+" "+DoubleToStr(ChardProfit,2)+"  ",12,"Arial",cl2);
           }
         else
           {
            ObjectDelete("pmk__CHprofit");
           }
        }
      //--
      //-- float--------------display-----

      Float = BuyProfit+SellProfit;
      if(Float < LowestFloat)
        {
         LowestFloat = Float;
        }
      if(Float> HighestFloat)
        {
         HighestFloat = Float;
        }

      // Dohvatite vrijednosti koje želite prikazati
      double currentFloat = Float;
      double maxFloat = LowestFloat;

      Write2("pmk_1010Float",3,15,45,"Float: "+DoubleToString(currentFloat, 1)+"  MinFloat: "+DoubleToString(maxFloat, 1)  +" ",10,"Vedana",White);
      //--------------------------------------------------------------------------------//
      //------------------------------display za total profit && total float -----------//
      //---------------------------------------------------------------------------------//

      Assign_Symbols2();

      totlots2 =0.0;
      tottrades2 = 0.0;
      totopnl2 =0.0;
      totcpnl2 =0.0;

      for(int qt2 =0;  t <=20; qt2++)
        {
         if(StringLen(symbols2[qt2])==0)
            break;
         if(MagicNumber>0)
           {
            Output_Row2(qt2, symbols2[qt2]);  //za reset ako stavimo magic==0
           }
        }
      int row2 = qt2;
      Rows2=row2;

      // SetLabel2("objClosedPnL" + row2, DoubleToStr(totcpnl2+totopnl2-OrderCommission()-OrderSwap(),2), White, 50+xdist, 30+ydist + (row2 + 2)*14,4,12);
      Write2("pmk_1011Total",3,0,10,"Total Profit: "" "" ",10,"Vedana",White);
      color bojaTotal;
      //double TotalProfit2=totcpnl2+totopnl2-OrderCommission()-OrderSwap();
      double TotalProfit2=totcpnl2+totopnl2;//otvoreni+zatvoreni nalozi+float

      if(TotalProfit2==0)
        {
         bojaTotal=Yellow;
        }
      else
         if(TotalProfit2<0)
           {
            bojaTotal=Red;
           }
         else
            if(TotalProfit2>0)
              {
               bojaTotal=Lime;
              }
      // if (TotalProfit2>0){
      Write2("pmk_1012TotalProfit",3,95,8," "+DoubleToStr(TotalProfit2,2)+"  "" ",10,"Vedana",bojaTotal); //}
      Write2("pmk_1013TotalFloat",3,0,25,"Total Float: "" "" ",10,"Vedana",White);
      color bojaTotalFloat;
      if(totopnl2==0)
        {
         bojaTotalFloat=Yellow;
        }
      else
         if(totopnl2<0)
           {
            bojaTotalFloat=Red;
           }
         else
            if(totopnl2>0)
              {
               bojaTotalFloat=Lime;
              }
      Write2("pmk_1014TotalFloat",3,95,25," "+DoubleToStr(totopnl2,2)+"  "" ",10,"Vedana",bojaTotalFloat);
      Write2("pmk_1015Linija",3,0,35,"--------------------------- ""  "" ",12,"Vedana",Yellow);

      //----------MidPoint linija

      if(ObjectFind("MidPoint") != 0)
        {
         ObjectCreate("MidPoint", OBJ_HLINE, 0, Time[0], MidPoint);
         ObjectSet("MidPoint", OBJPROP_COLOR, Gold);
         ObjectSet("MidPoint", OBJPROP_WIDTH, 2);
         ObjectSet("MidPoint", OBJPROP_BACK, true);//sa ovim se prikazuje iza back labela inace je ispred
        }
      else
        {
         ObjectMove("MidPoint", 0, Time[0], MidPoint);
        }
      //--
     }//if right side label
//-------------------

//--spread

   current_spread=(SymbolInfoDouble(Symbol(),SYMBOL_ASK)-SymbolInfoDouble(Symbol(),SYMBOL_BID))/Point*0.1;

   if(current_spread > max_spread)
     {
      max_spread = current_spread;
     }
   if(current_spread< min_spread)
     {
      min_spread = current_spread;
     }
   if(min_spread==0)
     {
      min_spread=current_spread;
     }

//-----------------------------------SPREAD Display----&&Stop Spread stop signal----------------------------------------
   if(current_spread<MaxSpread)
     {SpreadStop= false ; }
   else
     {
      SpreadStop=true;
     }

   if(current_spread>MaxSpread&& BuyOrders==0 && SellOrders==0)
     { Write1("pmk_100",0,0,110,5,"Spread is to high. "+current_spread+" "" Trade DISABLED",9,"Vedana",Red);}
   else
      if(current_spread>MaxSpread&& (BuyOrders>0 || SellOrders>0))
        { Write1("pmk_100",0,0,110,5,"Spread is to high. "+current_spread+" "" Trade PAUSED",9,"Vedana",Red); }
      else
         if(current_spread<MaxSpread)
           { Write1("pmk_100",0,0,110,5,"SPREAD  "+current_spread+" "" ",9,"Vedana",Lime);}



//+------------------------------------------------Session Profit stop--------------------------
   if(SesProfit>=SessionTarget&&SessionTarget>0)
     {
      ExitAllTrades(Aqua, "Session Target Achieved. YUHUUI!");
      SessionTargetStop=true;
      if(ObjectFind("pmk_Session")!=0)
        {
         ObjectCreate("pmk_Session",OBJ_LABEL,0,0,0);
         ObjectSet("pmk_Session",OBJPROP_CORNER,3);
         ObjectSet("pmk_Session",OBJPROP_XDISTANCE,300);
         ObjectSet("pmk_Session",OBJPROP_YDISTANCE,300);
        }
      else
        {
         ObjectSetText("pmk_Session"," Trade Stop Session Target Reached "+SessionTarget+"  ",20,"Arial Bold",Lime);
        }
      //---------
     }
   else
      if(SessionTarget==0)
        {
         SessionTargetStop=false;
         if(ObjectFind("pmk_Session")!=0)
           {
            ObjectDelete("pmk_Session");
           }
        }
//------------------------------------------------------        
//-----------------------TradeType-------------Display--
//------------------------------------------------------
   if(ManualButtons==false)
     {
      string TradeType;
  
      if(Trade_Type_==11)
        {
         TradeType=" Pending_Mode    ";
        }  
      //---------------------------------
        { Write1("pmk_101",0,0,110,20,"TradeType : "+TradeType+" "" ",9,"Vedana",Orange); }


     }
   if(ManualButtons==true)
     {    Write1("pmk_101",0,0,110,20," "" "" ",9,"Vedana",Orange); }
//---------------------------------EA name ---------------------
//--------------------------------------------------------------
   color pitura;
   if(ChardProfit >0)
     {
      pitura=Lime;
     }
   else
      if(ChardProfit <0)
        {
         pitura=Red;
        }
      else
         if(ChardProfit ==0)
           {
            pitura=Yellow;
           }
     { Write1("pmk_102",0,0,10,5,""+EA_name+" "" ",12,"Arial Bold",pitura); }
//---------------------------------

     /*        //--------------------------------------------------------------------------
      //-----------------------------------TEST Display poruka------------------
   //-----------------------------------------------------------------------
 
 
 
   
      if(ObjectFind("pmk_Di")!=0)
        {
          ObjectCreate("pmk_Di",OBJ_LABEL,0,0,0);
         ObjectSet("pmk_Di",OBJPROP_CORNER,3);
         ObjectSet("pmk_Di",OBJPROP_XDISTANCE,700);
         ObjectSet("pmk_Di",OBJPROP_YDISTANCE,250);
        }
      else
        {
         ObjectSetText("pmk_Di"," BuySpacing "+currentBuySpacing+" SellOrders "+SellOrders+" SellSpacing "+currentSellSpacing +"BuyOrders "+BuyOrders +"  ",10,"Arial Bold",Lime);
        }
 */ //--------------------------------------------------------------------------

//---------------------------------------------------
//------------------------indicator profit multichard
//----------------------------------------------------

//-----------------------------------
   /*
   if(ManualButtons==false)

   {
   if (MultichardDisplay==true){
   */

//***********************************************************************************************************
   Assign_Symbols();

//*********************************************************************************************************

   totlots =0.0;
   tottrades = 0.0;
   totopnl =0.0;
   totcpnl =0.0;

   for(int qt =0;  t <=20; qt++)
     {
      if(StringLen(symbols[qt])==0)
         break;
      if(MagicNumber>0)
        {
         Output_Row(qt, symbols[qt]);  //za reset ako stavimo magic==0
        }
     }

//------------------dodana boja---------------------
   color colorFloat,colorClosed;
   if(totopnl<0)
     {
      colorFloat=Red;
     }
   else
     {
      colorFloat=White;
     }
   if(totcpnl+totopnl >0)
     {
      colorClosed=Lime;
     }
   if(totcpnl+totopnl ==0)
     {
      colorClosed=White;
     }
   if(totcpnl+totopnl <0)
     {
      colorClosed=Red;
     }
//---------------------------------------

   if(tottrades>MaxOrders)
     {
      MaxOrders=tottrades;
     }
   if(totlots >MaxLots)
     {
      MaxLots=totlots;
     }
   if(totopnl <MinFloat)
     {
      MinFloat=totopnl;
     }
   if(totcpnl+totopnl>MaxPrMtch)
     {
      MaxPrMtch = totcpnl+totopnl;
     }
   int row = qt;
   Rows=row;
//--
   if(ManualButtons==false)

     {
      if(MultichardDisplay==true)
        {
         if(MagicNumber>0)
           {

            //--

            //---red za Symbols oznake
            SetLabel("objSymbol", "Symbol", Orange, 300+xdist, 25+ydist);//DimGray
            SetLabel("objTrades", "Ord   ", Orange, 250+xdist, 25+ydist);
            SetLabel("objLots", "Lots", Orange, 190+xdist, 25+ydist);
            SetLabel("objFloat", "Float", Orange, 120+xdist, 25+ydist);
            SetLabel("objClosedPnL", "Profit", Orange, 50+xdist, 25+ydist);
            if(Rows>0)
              {

               //red za TOTAL orders
               SetLabel2("objSymbol" + row, "Totals", White, 300+xdist, 30+ydist+ (row + 2)*14,4,11);
               SetLabel2("objTrades" + row, DoubleToStr(tottrades,0), White, 255+xdist, 30+ydist + (row + 2)*14,4,11);
               SetLabel2("objLots" + row, DoubleToStr(totlots,2), White, 190+xdist, 30+ydist + (row + 2)*14,4,11);
               SetLabel2("objFloat" + row, DoubleToStr(totopnl,2), colorFloat, 120+xdist, 30+ydist + (row + 2)*14,4,11);
               SetLabel2("objClosedPnL" + row, DoubleToStr(totcpnl+totopnl-OrderCommission()-OrderSwap(),2), colorClosed, 50+xdist, 30+ydist + (row + 2)*14,4,12);

               //---red za MAXIMUM orders
               SetLabel2("objMax"+ row+row, "Maximum", Orange, 300+xdist, 25+ydist+ (row+1)*14,4,11); //dodan jos jedan red za ocitanje
               SetLabel2("objMaxOrders" + row+row, """"+MaxOrders+"     ", Orange, 255+xdist, 25+ydist+ (row+1)*14,4,11);//dodan jos jedan red za ocitanje
               SetLabel2("objMaxLots" + row+row, ""+DoubleToStr(MaxLots,2)+" ", Orange, 190+xdist, 25+ydist+ (row+1)*14,4,11);//dodan jos jedan red za ocitanje
               SetLabel2("objMaxFloat" + row+row, ""+DoubleToStr(MinFloat,2)+"", Orange, 120+xdist, 25+ydist+ (row+1)*14,4,11);//dodan jos jedan red za ocitanje
               SetLabel2("objMaxClosedPnL" + row+row, ""+ DoubleToStr(MaxPrMtch,2)+"", Orange, 50+xdist, 25+ydist+ (row+1)*14,4,11); //dodan jos jedan red za ocitanje
              }
            return(Rows);


            if(MagicNumber<=0)
              {
               MaxOrders=0;
               MaxLots=0;
               MinFloat=0;
               MaxPrMtch=0;
               tottrades=0;
               totlots=0;
               totopnl=0;
               totcpnl=0;
               totopnl=0;
               Rows=0;
              }

           }//dodano za indicator multiprofit

        }//multichard display true false

     }//multichard display true false

   return(0);
  }
//--------------------------------
//-------------KRAJ START FUNKCIJE



//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void Write(string String)
  {
   int Handle;

   if(!Auditing)
      return;

   Handle = FileOpen(Filename, FILE_READ|FILE_WRITE|FILE_CSV, "/t");
   if(Handle < 1)
     {
      Print("Error opening audit file: Code ", GetLastError());
      return;
     }

   if(!FileSeek(Handle, 0, SEEK_END))
     {
      Print("Error seeking end of audit file: Code ", GetLastError());
      return;
     }

   if(FileWrite(Handle, TimeToStr(CurTime(), TIME_DATE|TIME_SECONDS) + "  " + String) < 1)
     {
      Print("Error writing to audit file: Code ", GetLastError());
      return;
     }

   FileClose(Handle);
  }
//---------------------------------------------------
//-----------------------------SIGNAL TRADE DIRECTION
//---------------------------------------------------



//-------------------------------------------------
double SessionProfit()
  {
   double profitHistory;
   double profitOpenP;
   double returnValue;

   for(int i = OrdersHistoryTotal()-1; i>=0; i--)
     {
      dummyResult=OrderSelect(i,SELECT_BY_POS,MODE_HISTORY);
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber)
        {
         if(OrderComment()==TradeComment)
           {
            profitHistory +=OrderProfit();
           }
        }
     }

   for(int j=OrdersTotal()-1; j>=0; j--)
     {
      dummyResult=OrderSelect(j,SELECT_BY_POS,MODE_TRADES);
      if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber)
        {
         if(OrderComment()==TradeComment)
           {
            profitOpenP +=OrderProfit();
           }
        }
     }

   returnValue=profitHistory+profitOpenP;
   return(returnValue);
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void ExitAllTrades(color Color, string reason)
  {
   bool success;
   for(int cnt = OrdersTotal() - 1; cnt >= 0; cnt --)
     {
      dummyResult=OrderSelect(cnt, SELECT_BY_POS, MODE_TRADES);
      if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
        {
         success=OrderClose(OrderTicket(), OrderLots(), OrderClosePrice(), Slippage, Color);
         if(success==true)
           {
            Print("Closed all positions because ",reason);
           }
        }
     }
  }
//----------------------------------------------------------------------------------------
//-----------------MANUAL BUTTONS----------------------------------------------------------
//----------------------------------------------------------------------------------------
void OnChartEvent(const int id,const long &lparm,const double &dparm,const string &sparm)
  {
  // int ticket;
   if(id==CHARTEVENT_OBJECT_CLICK)
     {
      if(sparm =="BuyButton")
        {
        // ticket= OrderSend(_Symbol,OP_BUY,ManualLots,Ask,Slippage,0,0,TradeComment,MagicNumber,Yellow);
         
          PlaceManualBuyOrder(ManualLots,ManualTrade_SL);
          
        }
     //--   
      if(sparm =="SellButton")
        {
          //ticket= OrderSend(_Symbol,OP_SELL,ManualLots,Bid,Slippage,0,0,TradeComment,MagicNumber,Yellow);
           PlaceManualSellOrder(ManualLots,ManualTrade_SL);
        }
    //--    
      if(sparm =="UP")
        {
         ManualLots=manualLots+ManualLots;
        }
      if(sparm =="DOWN")
        {
         ManualLots=ManualLots-manualLots;
         if(ManualLots<=0)
            ManualLots=0;
        }

      if(sparm =="CloseSellInProfit")
        {
         //CloseSellsInProfit=true;
         CloseSellsInProfit();
        }
      else
        {
         CloseSellsInProfit=false;
        }
      if(sparm =="CloseSellAll")
        {
         // CloseSells =true;
         CloseAllThisSymbolSell();
        }


      else
        {
         CloseSells =false;
        }
      //--
      if(sparm =="CloseBuyProfit")
        {
         // CloseBuysInProfit=true;
         CloseBuysInProfit();
        }
      else
        {
         CloseBuysInProfit=false;
        }
      if(sparm =="CloseBuyAll")
        {
         // CloseBuys =true;}
         CloseAllThisSymbolBuy();
        }
      else
        {
         CloseBuys =false;
        }
       //--------------------- 
      //-------------PENDINGS
      ///--------------------
      if(sparm =="BuyStop")
        {
         if(pendingSL>0)
           {
            double bSL=(Ask+PendingSpacing*Point-pendingSL*Point);
           }
         else
            bSL=0;
         if(pendingTP>0)
           {
            double bTP= (Ask+PendingSpacing*Point+pendingTP*Point);
           }
         else
            bTP=0;
         int  bes=OrderSend(Symbol(), OP_BUYSTOP,(PendingLots), Ask+PendingSpacing*Point, 3,bSL,bTP, "", MagicNumber, 0, Blue);
        }

      if(sparm =="SellLimit")
        {
         int res;
         if(pendingSL>0)
           {
            double sSL= (Bid+PendingSpacing*Point+pendingSL*Point);
           }
         else
            sSL=0;
         if(pendingTP>0)
           {
            double sTP =(Bid+PendingSpacing*Point-pendingTP*Point);
           }
         else
            sTP=0;
         res=OrderSend(Symbol(), OP_SELLLIMIT,PendingLots, Bid+PendingSpacing*Point, 3, sSL,sTP, "", MagicNumber, 0, Red);
        }
      //--
      if(sparm=="PendingClose")
        {
         bool  dummyResult2,dummyResult3,dummyResult4;
         RefreshRates();

         for(Order=OrdersTotal()-1; Order>=0; Order--)
           {
            if(OrderSelect(Order,SELECT_BY_POS,MODE_TRADES))
              {
               if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber && OrderType()==OP_BUYSTOP)
                 {
                  if((TimeCurrent()-OrderOpenTime()>=0))
                     dummyResult=OrderDelete(OrderTicket(),Green);//IsTesting() ||
                 }
               if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber && OrderType()==OP_SELLSTOP)
                 {
                  if((TimeCurrent()-OrderOpenTime()>=0))
                     dummyResult2=OrderDelete(OrderTicket(),Green);//IsTesting() ||
                 }
               if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber && OrderType()==OP_BUYLIMIT)
                 {
                  if((TimeCurrent()-OrderOpenTime()>=0))
                     dummyResult3=OrderDelete(OrderTicket(),Green);//IsTesting() ||
                 }
               if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber && OrderType()==OP_SELLLIMIT)
                 {
                  if((TimeCurrent()-OrderOpenTime()>=0))
                     dummyResult4=OrderDelete(OrderTicket(),Green);//IsTesting() ||
                 }

               Error=GetLastError();
               if(Error!=0)
                  Write("Error closing SELL order "+OrderTicket()+": "+ErrorDescription(Error)+" (B"+Error+")  Lots:"+OrderLots()+"  Ask:"+MarketInfo(OrderSymbol(),MODE_ASK));
              }
            //    }
            //  }
            //  }
            //  }
           }
         return;
        }
      //--
      if(sparm=="PendingLots+")
        {
         PendingLots=pendingLots+PendingLots;
        }
      //------------------
      if(sparm=="PendingLots-")
        {
         PendingLots=PendingLots-pendingLots;
         if(PendingLots<=0)
            PendingLots=0;
        }
      //--PendingSpacing PendingSpacing
        if(sparm=="PendingSpacing")
        {
         PendingSpacing=pendingSpacing;
        }
      //--    
      if(sparm=="Spacing+")
        {
         PendingSpacing=PendingSpacing+pendingSpacing;
        }
      //--
      if(sparm=="Spacing-")
        {
         PendingSpacing=PendingSpacing-pendingSpacing;
         if(PendingSpacing<=pendingSpacing)
            PendingSpacing=pendingSpacing;
        }
      //--
      if(sparm=="BuyLimit")
        {
       int es;
         if(pendingSL>0)
           {
            double bbSL= (Ask-PendingSpacing*Point-pendingSL*Point);
           }
         else
            bbSL=0;
         if(pendingTP>0)
           {
            double bbTP =(Ask-PendingSpacing*Point+pendingTP*Point);
           }
         else
            bbTP=0;
         es=OrderSend(Symbol(), OP_BUYLIMIT,PendingLots, Ask-PendingSpacing*Point, 3,bbSL,bbTP, "", MagicNumber, 0, Blue);
        
        // PlacePendingBuyLimit();
       //  ManualBuyLimit();
        }
      //--
      if(sparm=="SellStop")
        {
         int yres;
         if(pendingSL>0)
           {
            double ssSL= (Bid-PendingSpacing*Point+pendingSL*Point);
           }
         else
            ssSL=0;
         if(pendingTP>0)
           {
            double ssTP =(Bid-PendingSpacing*Point-pendingTP*Point);
           }
         else
            ssTP=0;
         yres=OrderSend(Symbol(), OP_SELLSTOP,PendingLots, Bid-PendingSpacing*Point, 3,ssSL,ssTP, "", MagicNumber, 0, Red);
        }
      //--
      if(sparm=="Display")
        {
         //----------button za vizualno gasenje

         value_to_toggle = !value_to_toggle;

        }
      //--
      //--
      if(sparm=="Alarm")
        {
         //----------button za vizualno gasenje

         value_to_toggle2 = !value_to_toggle2;

        }
      //--
      //--
      if(sparm=="CloseMultichard")//----------button za gasenje svih naloga na svim kartama
        {
         ExitAllTradesMultichard(Lime,"Manual Closed Multichard Orders");
        }

      if(sparm=="CloseALLSymbolsALLChard")//----------button za gasenje svih naloga na svim kartama
        {
         ExitAllTradesMultichard(Lime,"Manual Closed Multichard Orders");
        }




      if(sparm=="ManualLots+")
        {
         ManualLots=ManualLots+manualLots*10;
        }
      //--
      if(sparm=="ManualLots-")
        {
         ManualLots=ManualLots-manualLots*10;
         if(ManualLots<=0)
            ManualLots=0;
        }
      //--
      if(sparm=="Reset")
        {
         ManualLots=0;
         if(ManualLots<=0)
            ManualLots=0;
        }

      //--
      if(sparm=="CloseHighestBuy")
        {
         // CloseHighestBuy();
         CloseHighestBuy1=true;
         RefreshRates();
        }
      //--
      if(sparm=="CloseLowestBuy")
        {
         // CloseLowestBuy();
         CloseLowestBuy1=true;
         RefreshRates();
        }

      //--
      if(sparm=="CloseHighestSell")
        {
         // CloseHighestSell();
         CloseHighestSell1=true;
         RefreshRates();
        }
      //--
      if(sparm=="CloseLowestSell")
        {
         // CloseLowestSell();
         CloseLowestSell1=true;
         RefreshRates();
        }
      //--manual profit target

      if(sparm=="ProfitTarget")
        {
         ManualProfitTargetSet=ManualProfitTarget;
         if(ManualProfitTarget<=0)
            ManualProfitTarget=0;


        }
      //--
      if(sparm=="ProfitTargetReset")
        {
         ManualProfitTarget=0;
         ManualProfitTargetSet=0;
         if(ManualProfitTarget<=0)
            ManualProfitTarget=0;
         SetBoja=NoSet;
        }
      //--
      if(sparm =="ProfitTargetUP")
        {
         ManualProfitTarget=ManualProfitTarget +0.1;
         if(ManualProfitTarget>ManualProfitTargetSet)
           {ManualProfitTargetSet=0;}

        }
      //-
      if(sparm =="ProfitTargetDOWN")
        {
         ManualProfitTarget=ManualProfitTarget-0.1;
         if(ManualProfitTarget<=0)
            ManualProfitTarget=0;
         if(ManualProfitTarget<ManualProfitTargetSet)
           {ManualProfitTargetSet=0;}
        }
      //--
      if(sparm =="ProfitTargetLots+")
        {
         ManualProfitTarget=ManualProfitTarget +1;
         if(ManualProfitTarget>ManualProfitTargetSet)
           {ManualProfitTargetSet=0;}
        }
      //-
      if(sparm =="ProfitTargetLots-")
        {
         ManualProfitTarget=ManualProfitTarget-1;
         if(ManualProfitTarget<=0)
            ManualProfitTarget=0;
         if(ManualProfitTarget<ManualProfitTargetSet)
           {ManualProfitTargetSet=0;}
        }
      //--
      if(sparm =="ProfitTargetLots1+")
        {
         ManualProfitTarget=ManualProfitTarget +10;
         if(ManualProfitTarget>ManualProfitTargetSet)
           {ManualProfitTargetSet=0;}
        }
      //-
      if(sparm =="ProfitTargetLots1-")
        {
         ManualProfitTarget=ManualProfitTarget-10;
         if(ManualProfitTarget<=0)
            ManualProfitTarget=0;
         if(ManualProfitTarget<ManualProfitTargetSet)
           {ManualProfitTargetSet=0;}
        }
      //--

      //--manual profit secure

      if(sparm=="SecureProfit")
        {
         SecureProfitSet=SecureProfit;
         if(SecureProfit<=0)
            SecureProfitSet=0;


        }
      //--
      if(sparm=="SecureProfitReset")
        {
         SecureProfit=0;
         SecureProfitSet=0;
         if(SecureProfit<=0)
            SecureProfitSet=0;
         SecureBoja=NoSec;
        }
      //--
      if(sparm =="SecureProfitUP")
        {
         SecureProfit=SecureProfit +0.1;
         if(SecureProfit>SecureProfitSet)
           {SecureProfitSet=0;}

        }
      //-
      if(sparm =="SecureProfitDOWN")
        {
         SecureProfit=SecureProfit-0.1;
         if(SecureProfit<=0)
            SecureProfit=0;
         if(SecureProfit<SecureProfitSet)
           {SecureProfitSet=0;}
        }
      //--
      if(sparm =="SecureProfitLots+")
        {
         SecureProfit=SecureProfit +1;
         if(SecureProfit>SecureProfitSet)
           {SecureProfitSet=0;}
        }
      //-
      if(sparm =="SecureProfitLots-")
        {
         SecureProfit=SecureProfit-1;
         if(SecureProfit<=0)
            SecureProfit=0;
         if(SecureProfit<SecureProfitSet)
           {SecureProfitSet=0;}
        }
      //--
      if(sparm =="SecureProfitLots1+")
        {
         SecureProfit=SecureProfit +10;
         if(SecureProfit>SecureProfitSet)
           {SecureProfitSet=0;}
        }
      //-
      if(sparm =="SecureProfitLots1-")
        {
         SecureProfit=SecureProfit-10;
         if(SecureProfit<=0)
            SecureProfit=0;
         if(SecureProfit<SecureProfitSet)
           {SecureProfitSet=0;}
        }
//----------------------------------------------------------


//----------------TrailingSecureProfit
    if(sparm=="TreilingSecureProfit")
        {
      
        TreilingSecureProfitSet=TreilingSecureProfit;
         if(TreilingSecureProfit<=0)
            {TreilingSecureProfitSet=0;}
      //  initialSecureProfitSet = true;
        TreilingSecureBoja=SetTr;
        }
      //--
      if(sparm=="TreilingSecureProfitReset")
        {
       
         TreilingSecureProfit=0;
         TreilingSecureProfitSet=0;
        // if(TreilingSecureProfit<=0)
        //    TreilingSecureProfitSet=0;
            TreilingSecureBoja=NoSetTr;
            profitTemp = 0; // Privremena varijabla za praćenje trenutnog profita
            secureProfit = 0; // Početna vrijednost secure profita
            lastSecureProfit = 0; // Zadnja povećana vrijednost secure profita
            initialSecureProfitSet = false; // Indikator je li secure profit inicijalno postavljen
            //Manual_SecureProfit_Treiling=false;
        }
      //--
      if(sparm =="TreilingSecureProfitUP")
        {
         TreilingSecureProfit=TreilingSecureProfit +0.1;
         if(TreilingSecureProfit>TreilingSecureProfitSet)
           {TreilingSecureProfitSet=0;}

        }
      //-
      if(sparm =="TreilingSecureProfitDOWN")
        {
         TreilingSecureProfit=TreilingSecureProfit-0.1;
         if(TreilingSecureProfit<=0)
            TreilingSecureProfit=0;
         if(TreilingSecureProfit<TreilingSecureProfitSet)
           {TreilingSecureProfitSet=0;}
        }
      //--
      if(sparm =="TreilingSecureProfit+")
        {
         TreilingSecureProfit=TreilingSecureProfit +1;
         if(TreilingSecureProfit>TreilingSecureProfitSet)
           {TreilingSecureProfitSet=0;}
        }
      //-
      if(sparm =="TreilingSecureProfit-")
        {
         TreilingSecureProfit=TreilingSecureProfit-1;
         if(TreilingSecureProfit<=0)
            TreilingSecureProfit=0;
         if(TreilingSecureProfit<TreilingSecureProfitSet)
           {TreilingSecureProfitSet=0;}
        }
      //--
      if(sparm =="TreilingSecureProfit1+")
        {
         TreilingSecureProfit=TreilingSecureProfit +10;
         if(TreilingSecureProfit>TreilingSecureProfitSet)
           {TreilingSecureProfitSet=0;}
        }
      //-
      if(sparm =="TreilingSecureProfit1-")
        {
         TreilingSecureProfit=TreilingSecureProfit-10;
         if(TreilingSecureProfit<=0)
            TreilingSecureProfit=0;
         if(TreilingSecureProfit<TreilingSecureProfitSet)
           {TreilingSecureProfitSet=0;}
        }
//--------------------------------------------------------

      //--manual secureBUYprofit

      if(sparm=="SecureBUYProfit")
        {
         SecureBUYProfitSet=SecureBUYProfit;
         if(SecureBUYProfit<=0)
            SecureBUYProfitSet=0;


        }
      //--
      if(sparm=="SecureBUYProfitReset")
        {
         SecureBUYProfit=0;
         SecureBUYProfitSet=0;
         if(SecureBUYProfit<=0)
            SecureBUYProfitSet=0;
         SecureBUYBoja=BUYNoSec;
        }
      //--
      if(sparm =="SecureBUYProfitUP")
        {
         SecureBUYProfit=SecureBUYProfit +0.1;
         if(SecureBUYProfit>SecureBUYProfitSet)
           {SecureBUYProfitSet=0;}

        }
      //-
      if(sparm =="SecureBUYProfitDOWN")
        {
         SecureBUYProfit=SecureBUYProfit-0.1;
         if(SecureBUYProfit<=0)
            SecureBUYProfit=0;
         if(SecureBUYProfit<SecureBUYProfitSet)
           {SecureBUYProfitSet=0;}
        }
      //--
      if(sparm =="SecureBUYProfitLots+")
        {
         SecureBUYProfit=SecureBUYProfit +1;
         if(SecureBUYProfit>SecureBUYProfitSet)
           {SecureBUYProfitSet=0;}
        }
      //-
      if(sparm =="SecureBUYProfitLots-")
        {
         SecureBUYProfit=SecureBUYProfit-1;
         if(SecureBUYProfit<=0)
            SecureBUYProfit=0;
         if(SecureBUYProfit<SecureBUYProfitSet)
           {SecureBUYProfitSet=0;}
        }
      //--
      if(sparm =="SecureBUYProfitLots1+")
        {
         SecureBUYProfit=SecureBUYProfit +10;
         if(SecureBUYProfit>SecureBUYProfitSet)
           {SecureBUYProfitSet=0;}
        }
      //-
      if(sparm =="SecureBUYProfitLots1-")
        {
         SecureBUYProfit=SecureBUYProfit-10;
         if(SecureBUYProfit<=0)
            SecureBUYProfit=0;
         if(SecureBUYProfit<SecureBUYProfitSet)
           {SecureBUYProfitSet=0;}
        }

      //--manual secureSELLprofit

      if(sparm=="SecureSELLProfit")
        {
         SecureSELLProfitSet=SecureSELLProfit;
         if(SecureSELLProfit<=0)
            SecureSELLProfitSet=0;


        }
      //--
      if(sparm=="SecureSELLProfitReset")
        {
         SecureSELLProfit=0;
         SecureSELLProfitSet=0;
         if(SecureSELLProfit<=0)
            SecureSELLProfitSet=0;
         SecureSELLBoja=SELLNoSec;
        }
      //--
      if(sparm =="SecureSELLProfitUP")
        {
         SecureSELLProfit=SecureSELLProfit +0.1;
         if(SecureSELLProfit>SecureSELLProfitSet)
           {SecureSELLProfitSet=0;}

        }
      //-
      if(sparm =="SecureSELLProfitDOWN")
        {
         SecureSELLProfit=SecureSELLProfit-0.1;
         if(SecureSELLProfit<=0)
            SecureSELLProfit=0;
         if(SecureSELLProfit<SecureSELLProfitSet)
           {SecureSELLProfitSet=0;}
        }
      //--
      if(sparm =="SecureSELLProfitLots+")
        {
         SecureSELLProfit=SecureSELLProfit +1;
         if(SecureSELLProfit>SecureSELLProfitSet)
           {SecureSELLProfitSet=0;}
        }
      //-
      if(sparm =="SecureSELLProfitLots-")
        {
         SecureSELLProfit=SecureSELLProfit-1;
         if(SecureSELLProfit<=0)
            SecureSELLProfit=0;
         if(SecureSELLProfit<SecureSELLProfitSet)
           {SecureSELLProfitSet=0;}
        }
      //--
      if(sparm =="SecureSELLProfitLots1+")
        {
         SecureSELLProfit=SecureSELLProfit +10;
         if(SecureBUYProfit>SecureBUYProfitSet)
           {SecureSELLProfitSet=0;}
        }
      //-
      if(sparm =="SecureSELLProfitLots1-")
        {
         SecureSELLProfit=SecureSELLProfit-10;
         if(SecureSELLProfit<=0)
            SecureSELLProfit=0;
         if(SecureSELLProfit<SecureSELLProfitSet)
           {SecureSELLProfitSet=0;}
        }

     }
  }
//----------------------------------------------------------------------------

//-------------------
void CreateButton(string BTname,int Corner,int xDistance,int xSize,int yDistance,int ySize,color BGcolor,color Forecolor,string BTtext)
  {
   ObjectCreate(_Symbol,BTname,OBJ_BUTTON,0,0,0);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_CORNER,Corner);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_XDISTANCE,xDistance);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_XSIZE,xSize);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_YDISTANCE,yDistance);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_YSIZE,ySize);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_BGCOLOR,BGcolor);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_COLOR,Forecolor);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_STATE,false);
   ObjectSetString(_Symbol,BTname,OBJPROP_TEXT,BTtext);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_HIDDEN,false);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_BACK,false);
  }

//--------------------------------
void CreateButton2(string BTname,int Corner,int xDistance2,int xSize,int yDistance2,int ySize,color BGcolor,color Forecolor,string BTtext)
  {
   ObjectCreate(_Symbol,BTname,OBJ_BUTTON,0,0,0);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_CORNER,Corner);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_XDISTANCE,xDistance2+X_dist);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_XSIZE,xSize);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_YDISTANCE,yDistance2+Y_dist);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_YSIZE,ySize);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_BGCOLOR,BGcolor);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_COLOR,Forecolor);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_STATE,false);
   ObjectSetString(_Symbol,BTname,OBJPROP_TEXT,BTtext);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_HIDDEN,false);
   ObjectSetInteger(_Symbol,BTname,OBJPROP_BACK,false);
  }
//--//ispisivanje multichard profit displeja//--------------
void SetLabel(string name, string text, color clr, int xdistance, int ydistance, int corner=4,int fontsize=11)
  {
   if(ObjectFind(name)==-1)
     {
      ObjectCreate(name, OBJ_LABEL, 0, 0,0);
      ObjectSet(name, OBJPROP_XDISTANCE, xdistance-25);
      ObjectSet(name, OBJPROP_YDISTANCE, ydistance);
      ObjectSet(name, OBJPROP_CORNER, corner);
     }
   ObjectSetText(name, text, fontsize, "Arial", clr);

  }
//+--------------------------------------------------------------------------+
void SetLabel2(string name, string text, color clr, int xdistance, int ydistance, int corner,int fontsize)
  {
   if(ObjectFind(name)==-1)
     {
      ObjectCreate(name, OBJ_LABEL, 0, 0,0);
      ObjectSet(name, OBJPROP_XDISTANCE, xdistance-25);
      ObjectSet(name, OBJPROP_YDISTANCE, ydistance);
      ObjectSet(name, OBJPROP_CORNER, corner);
     }
   ObjectSetText(name, text, fontsize, "Arial", clr);

  }
//---------

//----------------------
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
double SessionProfitC()
  {

// double returnValue;

   double TotalProfitHistory,TotalLossHistory,TotalHistory;
   double TotalProfitFloat,TotalLossFloat,TotalFloat;

   for(Order=OrdersHistoryTotal(); Order>=0; Order--)
     {
      if(OrderSelect(Order,SELECT_BY_POS,MODE_HISTORY))
         //{
         //if(OrderOpenTime()>PlacingTime)
        {
         if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber && OrderProfit()>0)
           {
            TotalProfitHistory=TotalProfitHistory+(OrderProfit()+OrderSwap()+OrderCommission());
           }
         if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber && OrderProfit()<0)
           {
            TotalLossHistory=TotalLossHistory+(OrderProfit()+OrderSwap()+OrderCommission());
           }
        }
      // }
     }

   TotalHistory=TotalProfitHistory+TotalLossHistory;

   for(Order=OrdersTotal(); Order>=0; Order--)
     {
      if(OrderSelect(Order,SELECT_BY_POS,MODE_TRADES))
        {
         if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber && OrderProfit()>0)
           {
            TotalProfitFloat=TotalProfitFloat+(OrderProfit()+OrderSwap()+OrderCommission());
           }
         if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber && OrderProfit()<0)
           {
            TotalLossFloat=TotalLossFloat+(OrderProfit()+OrderSwap()+OrderCommission());
           }
        }
     }

   TotalFloat=TotalProfitFloat+TotalLossFloat;


   returnValueC=TotalHistory+TotalFloat;
   return(returnValueC);
  }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| Funkcija za stvaranje labele                                     |
//+------------------------------------------------------------------+
void CreateLabel(string name, int corner, int x, int y, string text, int size, color text_color)
  {
   ObjectCreate(name, OBJ_LABEL, 0, 0, 0);
   ObjectSetText(name, text, size, "Arial", text_color);
   ObjectSet(name, OBJPROP_CORNER, corner);
   ObjectSet(name, OBJPROP_XDISTANCE, x);
   ObjectSet(name, OBJPROP_YDISTANCE, y);
  }
//----------
//+------------------------------------------------------------------+
//| Write Procedure                                                  |
//+------------------------------------------------------------------+
void Write1(string LBL1, int window, double side, int pos_x, int pos_y, string text, int fontsize, string fontname, color Tcolor=CLR_NONE)

  {
   ObjectCreate(LBL1, OBJ_LABEL, 0, 0, 0);
// ObjectSet(LBL1, OBJPROP_FILL, Blue);
   ObjectSet(LBL1, OBJPROP_CORNER, 4);
   ObjectSet(LBL1, OBJPROP_XDISTANCE, pos_x+25);//+940
   ObjectSet(LBL1, OBJPROP_YDISTANCE, pos_y+15);
   ObjectSetText(LBL1,text, fontsize, fontname, Tcolor);

   ObjectSetText(LBL1,text, fontsize, fontname, Tcolor);
  }
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
void Write2(string LBL2, int corner, int pos_x, int pos_y, string text, int fontsize, string fontname, color Tcolor)

  {
   ObjectCreate(LBL2, OBJ_LABEL, 0, 0, 0);
// ObjectSet(LBL1, OBJPROP_FILL, Blue);
   ObjectSet(LBL2, OBJPROP_CORNER, corner);
   ObjectSet(LBL2, OBJPROP_XDISTANCE, pos_x);//+940
   ObjectSet(LBL2, OBJPROP_YDISTANCE, pos_y);
   ObjectSetText(LBL2,text, fontsize, fontname, Tcolor);

   ObjectSetText(LBL2,text, fontsize, fontname, Tcolor);
  }
//+------------------------------------------------------------------+
void FrameLB(int FRcorner,int FRxD,int FRyD,int FRxS,int FRyS)
  {
//----------background color
   ObjectCreate("pmk_FrameLabel1",OBJ_RECTANGLE_LABEL,0,0,0,0,0,0);
   ObjectSet("pmk_FrameLabel1",OBJPROP_BGCOLOR,FrameColor);
   ObjectSet("pmk_FrameLabel1",OBJPROP_CORNER,FRcorner);//4
   ObjectSet("pmk_FrameLabel1",OBJPROP_BACK,false);//now it is in front of candles
   ObjectSet("pmk_FrameLabel1",OBJPROP_XDISTANCE,FRxD);//130
   ObjectSet("pmk_FrameLabel1",OBJPROP_YDISTANCE,FRyD);//40
   ObjectSet("pmk_FrameLabel1",OBJPROP_XSIZE,1*FRxS);//320
   ObjectSet("pmk_FrameLabel1",OBJPROP_YSIZE,1*FRyS);//260
   ObjectSet("pmk_FrameLabel1",OBJPROP_BORDER_TYPE,3);
   ObjectSet("pmk_FrameLabel1",OBJPROP_BORDER_COLOR,FrameColor);

  }

//+----------------------BAC LABEL FOR MANUAL ORDER BUTTON --------------------------------------------+
void FrameLBS(int FRcorner,int FRxD,int FRyD,int FRxS,int FRyS)
  {
//----------background color
   ObjectCreate("pmk_FrameLabel12",OBJ_RECTANGLE_LABEL,0,0,0,0,0,0);
   ObjectSet("pmk_FrameLabel12",OBJPROP_BGCOLOR,FrameColor);
   ObjectSet("pmk_FrameLabel12",OBJPROP_CORNER,FRcorner);//4
   ObjectSet("pmk_FrameLabel12",OBJPROP_BACK,false);//now it is in front of candles
   ObjectSet("pmk_FrameLabel12",OBJPROP_XDISTANCE,FRxD);//130
   ObjectSet("pmk_FrameLabel12",OBJPROP_YDISTANCE,FRyD);//40
   ObjectSet("pmk_FrameLabel12",OBJPROP_XSIZE,1*FRxS);//320
   ObjectSet("pmk_FrameLabel12",OBJPROP_YSIZE,1*FRyS);//260
   ObjectSet("pmk_FrameLabel12",OBJPROP_BORDER_TYPE,3);
   ObjectSet("pmk_FrameLabel12",OBJPROP_BORDER_COLOR,FrameColor);

  }

//-----------------background label za multichard
void FrameLB0(int FRcorner,int FRxD,int FRyD,int FRxS,int FRyS)
  {
//----------background color za multiframe label
   ObjectCreate("pmk_FrameLabel",OBJ_RECTANGLE_LABEL,0,0,0,0,0,0);
   ObjectSet("pmk_FrameLabel",OBJPROP_BGCOLOR,FrameColor);
   ObjectSet("pmk_FrameLabel",OBJPROP_CORNER,FRcorner);//1
   ObjectSet("pmk_FrameLabel",OBJPROP_BACK,false);//ispred candla i crta je sada ako je true onda su candle ispred labela
   ObjectSet("pmk_FrameLabel",OBJPROP_XDISTANCE,FRxD);//105
   ObjectSet("pmk_FrameLabel",OBJPROP_YDISTANCE,FRyD);//75
   ObjectSet("pmk_FrameLabel",OBJPROP_XSIZE,1*FRxS);//70
   ObjectSet("pmk_FrameLabel",OBJPROP_YSIZE,1*FRyS);//60
   ObjectSet("pmk_FrameLabel",OBJPROP_BORDER_TYPE,3);
   ObjectSet("pmk_FrameLabel",OBJPROP_BORDER_COLOR,FrameColor);

  }

//+------------------------------------------------------------------+
//------------indicator profit multivhard

//void Output_Row(int row, string sym)//original
double Output_Row(int row, string sym)
  {
   if(ManualButtons==false&&MultichardDisplay==true)
     {
      SetLabel("objSymbol" + row, sym, Gray, 300+xdist, 25+ydist + (row + 1)*14);
     }


   double trades =0;
   double lots = 0.00;
   double opnl = 0.00;
   double cpnl =0.00;
   double clots = 0.00;
   double ctrades = 0;
   int pos = 1, lcolor = DimGray;
   for(int i =0; i < OrdersTotal(); i++)
     {
      bool dummyResult5=    OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
      if((OrderMagicNumber() == MagicNumber || MagicNumber == -1) && OrderSymbol() == sym)
        {
         opnl += OrderProfit()+OrderCommission()+OrderSwap();
         lots += OrderLots();
         trades +=1;
         if(OrderType() == OP_SELL)
            pos = -1;
        }
     }
   if(pos == 1)
      lcolor = Lime;
   if(pos ==-1)
      lcolor = Red;
   int clr = Lime;
   if(opnl <0)
      clr = Red;
   if(ManualButtons==false&&MultichardDisplay==true)
     {
      SetLabel("objTrades" + row, DoubleToStr(trades,0), DimGray, 250+xdist, 25+ydist + (row + 1)*14);//xdist220
      SetLabel("objLots" + row, DoubleToStr(lots,2), lcolor, 190+xdist, 25+ydist + (row + 1)*14);//xdist 170
      // SetLabel("objOpenPnL" + row, DoubleToStr(opnl,2), clr, 100+xdist, 25+ydist + (row + 1)*14);
      SetLabel("objFloat" + row, DoubleToStr(opnl,2), clr, 120+xdist, 25+ydist + (row + 1)*14);//x dist 110
     }
   for(i =0; i < OrdersHistoryTotal(); i++)
     {
      dummyResult5=OrderSelect(i, SELECT_BY_POS, MODE_HISTORY);
      if((OrderMagicNumber() == MagicNumber || MagicNumber == -1) && OrderSymbol() == sym)
        {
         cpnl += OrderProfit()+OrderCommission()+OrderSwap();
         clots += OrderLots();
         ctrades +=1;
        }
     }
// if (cpnl >=0) lcolor = Lime; else lcolor = Red;//original
// SetLabel("objClosedPnL" + row, DoubleToStr(cpnl,2), lcolor, 50+xdist, 25+ydist + (row + 1)*14);//original

   if(cpnl+opnl >=0)
      lcolor = Lime;
   else
      lcolor = Red;
   if(ManualButtons==false&&MultichardDisplay==true)
     {
      SetLabel("objClosedPnL" + row, DoubleToStr(cpnl+opnl,2), lcolor, 50+xdist, 25+ydist + (row + 1)*14);
     }
   tottrades += trades;
   totlots += lots;
   totopnl += opnl;
   totcpnl += cpnl;

//--
   return(cpnl);
  }

//+------------------------------------------------------------------+






//--------------------------
void Assign_Symbols()
  {
   int i =0;
   for(i =0; i < OrdersHistoryTotal(); i++)
     {
      bool dummyResult5= OrderSelect(i, SELECT_BY_POS, MODE_HISTORY);
      if(OrderMagicNumber() == MagicNumber || MagicNumber == -1)
        {
         for(int k = 0; k<=20; k++)
           {
            if(OrderSymbol() == symbols[k])
               break;
            if(StringLen(symbols[k]) == 0)
              {
               symbols[k] = OrderSymbol();
               break;
              }
           }
        }
     }

   for(i=0; i<OrdersTotal(); i++)
     {
      dummyResult5=  OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
      if(OrderMagicNumber() == MagicNumber || MagicNumber == -1)
        {
         for(k = 0; k <=20; k++)
           {
            if(OrderSymbol() == symbols[k])
               break;
            if(StringLen(symbols[k]) == 0)
              {
               symbols[k] = OrderSymbol();
               break;
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
double Output_Row2(int row2, string sym2)
  {

// SetLabel("objSymbol" + row2, sym2, Gray, 300+xdist, 25+ydist + (row2 + 1)*14);//xdist 250
   double trades2 =0;
   double lots2 = 0.00;
   double opnl2 = 0.00;
   double cpnl2 =0.00;
   double clots2 = 0.00;
   double ctrades2 = 0;

   for(int i2 =0; i2 < OrdersTotal(); i2++)
     {
      bool dummyResult52=    OrderSelect(i2, SELECT_BY_POS, MODE_TRADES);
      if((OrderMagicNumber() == MagicNumber || MagicNumber == -1) && OrderSymbol() == sym2)
        {
         opnl2 += OrderProfit()+OrderCommission()+OrderSwap();
         lots2 += OrderLots();
         trades2 +=1;

        }
     }

   for(i2 =0; i2 < OrdersHistoryTotal(); i2++)
     {
      dummyResult52=OrderSelect(i2, SELECT_BY_POS, MODE_HISTORY);
      if((OrderMagicNumber() == MagicNumber || MagicNumber == -1) && OrderSymbol() == sym2)
        {
         cpnl2 += OrderProfit()+OrderCommission()+OrderSwap();
         clots2 += OrderLots();
         ctrades2 +=1;
        }
     }
//SetLabel("objClosedPnL" + row2, DoubleToStr(cpnl2+opnl2,2), White, 50+xdist, 25+ydist + (row2 + 1)*14);
   tottrades2 += trades2;
   totlots2 += lots2;
   totopnl2 += opnl2;
   totcpnl2 += cpnl2;

//--
   return(cpnl2);
  }

//+------------------------------------------------------------------+
//--------------------------
void Assign_Symbols2()
  {
   int i2 =0;
   for(i2 =0; i2 < OrdersHistoryTotal(); i2++)
     {
      bool dummyResult52= OrderSelect(i2, SELECT_BY_POS, MODE_HISTORY);
      if(OrderMagicNumber() == MagicNumber || MagicNumber == -1)
        {
         for(int k2 = 0; k2<=20; k2++)
           {
            if(OrderSymbol() == symbols2[k2])
               break;
            if(StringLen(symbols2[k2]) == 0)
              {
               symbols2[k2] = OrderSymbol();
               break;
              }
           }
        }
     }

   for(i2=0; i2<OrdersTotal(); i2++)
     {
      dummyResult52=  OrderSelect(i2, SELECT_BY_POS, MODE_TRADES);
      if(OrderMagicNumber() == MagicNumber || MagicNumber == -1)
        {
         for(k2 = 0; k2 <=20; k2++)
           {
            if(OrderSymbol() == symbols2[k2])
               break;
            if(StringLen(symbols2[k2]) == 0)
              {
               symbols2[k2] = OrderSymbol();
               break;
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
void ExitAllTradesMultichard(color Color,string reason)
  {
   bool success;
   for(int cnt=OrdersTotal(); cnt>=0; cnt --)
     {
      dummyResult=OrderSelect(cnt,SELECT_BY_POS,MODE_TRADES);
      // if(OrderSymbol()==Symbol() && OrderMagicNumber()==MagicNumber)
      if(OrderMagicNumber()==MagicNumber)
        {
         success=OrderClose(OrderTicket(),OrderLots(),OrderClosePrice(),Slippage,Color);
         if(success==true)
           {
            Print("Closed all positions because ",reason);
           }
        }
     }
  }



//---
void PlaceBuyOrder()
  {
   double BuyOrders, Lots;
   double LowestBuy = 1000, HighestBuy;

   TickPrice = 0;

   RefreshRates();

   for(Order = OrdersTotal() - 1; Order >= 0; Order--)
     {
      if(OrderSelect(Order, SELECT_BY_POS, MODE_TRADES))
        {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderType() == OP_BUY)
           {
            if(OrderOpenPrice() < LowestBuy)
               LowestBuy = OrderOpenPrice();
            if(OrderOpenPrice() > HighestBuy)
               HighestBuy = OrderOpenPrice();
            BuyOrders++;
           }
        }
     }

   if(Ask >= HighestBuy + (trendSpacing * Point))
     {

      if(Multiplier >0)
         Lots = NormalizeDouble(((LotSize +LotIncrement)*Multiplier*BuyOrders),lotPrecision);
      else
         Lots = NormalizeDouble(LotSize + (LotIncrement * BuyOrders), lotPrecision);
     }

   if(Ask <= LowestBuy - (spacing * Point))
     {

      if(CounterTrendMultiplier >0)

         Lots = NormalizeDouble(((LotSize +LotIncrement)*CounterTrendMultiplier*BuyOrders),lotPrecision);
      else
         Lots = NormalizeDouble(LotSize  + (LotIncrement * BuyOrders), lotPrecision);
     }

   if(BuyOrders==0)
     {
      Lots = NormalizeDouble(LotSize, lotPrecision);
     }

   if(Lots == 0)
     {
      if(Multiplier == 0)
         Lots = NormalizeDouble(LotSize, lotPrecision);
      else
         Lots = NormalizeDouble(LotSize*Multiplier, lotPrecision);

     }

   if(IsTradeAllowed()==true&&BuyOrders<MaximumBuyOrders)
     {
      dummyResult=OrderSend(Symbol(), OP_BUY, Lots, Ask, Slippage, 0, 0, TradeComment, MagicNumber, Green);
     }

   Error = GetLastError();
   if(Error != 0)
      Write("Error opening BUY order: " + ErrorDescription(Error) + " (C" + Error + ")  Ask:" + Ask + "  Slippage:" + Slippage);
   else
     {
      TickPrice = Close[0];
     }

  }
//-----
//----
void PlaceSellOrder()
  {
   double SellOrders, Lots;
   double HighestSell, LowestSell = 1000;

   TickPrice = 0;

   RefreshRates();

   for(Order = OrdersTotal() - 1; Order >= 0; Order--)
     {
      if(OrderSelect(Order, SELECT_BY_POS, MODE_TRADES))
        {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber && OrderType() == OP_SELL)
           {
            if(OrderOpenPrice() > HighestSell)
               HighestSell = OrderOpenPrice();
            if(OrderOpenPrice() < LowestSell)
               LowestSell = OrderOpenPrice();
            SellOrders++;
           }
        }
     }

   if(Bid <= LowestSell - (trendSpacing * Point))
     {

      if(Multiplier > 0)
         Lots = NormalizeDouble(((LotSize +LotIncrement)*Multiplier*SellOrders),lotPrecision);
      else
         Lots = NormalizeDouble(LotSize + (LotIncrement * SellOrders), lotPrecision);
     }

   if(Bid >= HighestSell + (spacing * Point))
     {
      if(CounterTrendMultiplier >0)
         Lots = NormalizeDouble(((LotSize +LotIncrement)*CounterTrendMultiplier*SellOrders),lotPrecision);
      else
         Lots = NormalizeDouble(LotSize  + (LotIncrement * SellOrders), lotPrecision);
     }

   if(SellOrders==0)
     {
      Lots = NormalizeDouble(LotSize, lotPrecision);
     }

   if(Lots == 0)
     {
      if(Multiplier ==0)
         Lots = NormalizeDouble(LotSize, lotPrecision);
      else
         Lots = NormalizeDouble(LotSize*Multiplier, lotPrecision);
     }

   if(IsTradeAllowed()==true&&SellOrders<MaximumSellOrders)
     {
      dummyResult=OrderSend(Symbol(), OP_SELL, Lots, Bid, Slippage, 0, 0, TradeComment, MagicNumber, Red);
     }

   Error = GetLastError();
   if(Error != 0)
      Write("Error opening SELL order: " + ErrorDescription(Error) + " (D" + Error + ")  Bid:" + Bid + "  Slippage:" + Slippage);
   else
     {
      TickPrice = Close[0];
     }
  }
  

//+------------------------------------------------------------------+
//-----------------------------------------------------------------------------
// Market Analysis Functions
//-----------------------------------------------------------------------------

// Funkcija za primjenu trailing stopa na sve naloge s prilagodbom prema broju naloga
void CheckAndApplyTrailingStop() {
    // Brojanje naloga s vašim Magic Number-om
    int totalActiveOrders = 0;
    for(int count=0; count<OrdersTotal(); count++) {
        if(OrderSelect(count, SELECT_BY_POS, MODE_TRADES)) {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                totalActiveOrders++;
            }
        }
    }
    
    // Izračun faktora skaliranja - linearno između 1 i 10 za raspon od 1 do 100 naloga
    double scaleFactor = 1.0;
    if(totalActiveOrders > 1) {
        // Linearno skaliranje između 1 i 10 bazirano na broju naloga od 1 do 100
        scaleFactor = 1.0 + (totalActiveOrders - 1) * 9.0 / 99.0;
        // Ograničenje na maksimalno 10x za više od 100 naloga
        if(scaleFactor > 10.0) scaleFactor = 10.0;
    }
    
    // Prilagođeni trailing stop i step
    int adjustedTrailingStop = (int)(TrailingStop * scaleFactor);
    int adjustedTrailingStep = (int)(TrailingStep * scaleFactor);
    
    // Primjena na sve naloge
    for(int i=0; i<OrdersTotal(); i++) {
        if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
            if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
                // Za BUY naloge
                if(OrderType() == OP_BUY) {
                    // Izračunaj potencijalnu novu SL cijenu s prilagođenim stop-om
                    double newStopLoss = NormalizeDouble(Bid - adjustedTrailingStop * Point, Digits);
                    
                    // Ako je cijena porasla dovoljno da se isplati pomaknuti SL
                    if(newStopLoss > OrderStopLoss() + adjustedTrailingStep * Point || OrderStopLoss() == 0) {
                        // Modifikacija naloga s novim SL
                        bool modified = OrderModify(OrderTicket(), OrderOpenPrice(), newStopLoss, OrderTakeProfit(), 0, Blue);
                      /*  if(modified) {
                            Print("Trailing Stop za BUY nalog #", OrderTicket(), " pomaknut na ", newStopLoss, 
                                  " (Scale Factor: ", scaleFactor, ", Orders: ", totalActiveOrders, ")");
                        } else {
                            Print("Greška pri pomicanju trailinga za BUY #", OrderTicket(), ": ", GetLastError());
                        }
                       */ 
                    }
                }
                // Za SELL naloge
                else if(OrderType() == OP_SELL) {
                    // Izračunaj potencijalnu novu SL cijenu s prilagođenim stop-om
                     newStopLoss = NormalizeDouble(Ask + adjustedTrailingStop * Point, Digits);
                    
                    // Ako je cijena pala dovoljno da se isplati pomaknuti SL
                    if(newStopLoss < OrderStopLoss() - adjustedTrailingStep * Point || OrderStopLoss() == 0) {
                        // Modifikacija naloga s novim SL
                        modified = OrderModify(OrderTicket(), OrderOpenPrice(), newStopLoss, OrderTakeProfit(), 0, Red);
                      /*  if(modified) {
                            Print("Trailing Stop za SELL nalog #", OrderTicket(), " pomaknut na ", newStopLoss,
                                  " (Scale Factor: ", scaleFactor, ", Orders: ", totalActiveOrders, ")");
                        } else {
                            Print("Greška pri pomicanju trailinga za SELL #", OrderTicket(), ": ", GetLastError());
                        }
                       */ 
                    }
                }
            }
        }
    }
}



// Dodajte ovu funkciju za izračun vremena do kraja ograničenja
int GetMinutesUntilRestrictionEnd()
{
   datetime currentTime = TimeCurrent();
   int currentHour = TimeHour(currentTime);
   int currentMinute = TimeMinute(currentTime);
   
   int currentTimeMinutes = currentHour * 60 + currentMinute;
   int endTimeMinutes = RestrictEndHour * 60 + RestrictEndMinute;
   
   // Ako je vrijeme ograničenja preko ponoći (npr. 18:00 do 06:00)
   if(RestrictStartHour > RestrictEndHour) {
      if(currentTimeMinutes >= 0 && currentTimeMinutes <= endTimeMinutes) {
         return endTimeMinutes - currentTimeMinutes;
      } else {
         return (24 * 60 - currentTimeMinutes) + endTimeMinutes;
      }
   }
   // Ako je vrijeme ograničenja unutar istog dana (npr. 09:00 do 17:00)
   else {
      return endTimeMinutes - currentTimeMinutes;
   }
}

// Dodajte ovu funkciju za prikaz/skrivanje poruke o ograničenju
void ManageTimeRestrictionDisplay(bool isRestricted, bool hasOpenOrders)
{
   if(isRestricted) {
      if(!isTimeRestrictionDisplayed) {
         // Stvori labele ako ne postoje
         if(ObjectFind(timeRestrictionLabel) < 0) {
            ObjectCreate(timeRestrictionLabel, OBJ_LABEL, 0, 0, 0);
            ObjectSet(timeRestrictionLabel, OBJPROP_CORNER, TimeRestrictionCorner);
            ObjectSet(timeRestrictionLabel, OBJPROP_XDISTANCE, 20);
            ObjectSet(timeRestrictionLabel, OBJPROP_YDISTANCE, 100);
         }
         
         if(ObjectFind(countdownLabel) < 0) {
            ObjectCreate(countdownLabel, OBJ_LABEL, 0, 0, 0);
            ObjectSet(countdownLabel, OBJPROP_CORNER, TimeRestrictionCorner);
            ObjectSet(countdownLabel, OBJPROP_XDISTANCE, 20);
            ObjectSet(countdownLabel, OBJPROP_YDISTANCE, 120);
         }
         
         isTimeRestrictionDisplayed = true;
      }
      
      // Postavi tekst poruke
      string statusText;
      if(hasOpenOrders) {
         statusText = "Time restriction: Waiting closing open trade";
      } else {
         statusText = "Time restriction: No Trade";
      }
      ObjectSetText(timeRestrictionLabel, statusText, TimeRestrictionFontSize, "Arial", TimeRestrictionTextColor);
      
      // Izračunaj i prikaži vrijeme do kraja ograničenja
      int minutesLeft = GetMinutesUntilRestrictionEnd();
      int hoursLeft = (int)MathFloor(minutesLeft / 60);
      int minsLeft = minutesLeft % 60;
      
      string countdownText = "Remeining time: " + hoursLeft + "h " + minsLeft + "m";
      ObjectSetText(countdownLabel, countdownText, TimeRestrictionFontSize, "Arial", TimeRestrictionTextColor);
      
      // Osvježi prikaz
      WindowRedraw();
   } else {
      // Ukloni labele ako postoje
      if(isTimeRestrictionDisplayed) {
         ObjectDelete(timeRestrictionLabel);
         ObjectDelete(countdownLabel);
         isTimeRestrictionDisplayed = false;
         WindowRedraw();
      }
   }
}

// Dodajte ovu funkciju negdje u EA
bool HasOpenOrders()
{
   int totalOrders = 0;
   for(int i=0; i<OrdersTotal(); i++) {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber) {
            if(OrderType() == OP_BUY || OrderType() == OP_SELL) {
               totalOrders++;
            }
         }
      }
   }
   return (totalOrders > 0);
}

// Dodajte ovu funkciju negdje u EA
bool IsTimeRestricted()
{
   if(!UseTimeRestriction) return false;
   
   datetime currentTime = TimeCurrent();
   int currentHour = TimeHour(currentTime);//original
   
   int currentMinute = TimeMinute(currentTime);
   
   int currentTimeMinutes = currentHour * 60 + currentMinute;
   int startTimeMinutes = RestrictStartHour * 60 + RestrictStartMinute;//dodano -3 na RestrictStartHours
   int endTimeMinutes = RestrictEndHour * 60 + RestrictEndMinute;//dodano -3 na RestrictEndHours
   
   // Ako je vrijeme ograničenja preko ponoći (npr. 18:00 do 06:00)
   if(startTimeMinutes > endTimeMinutes) {
      return (currentTimeMinutes >= startTimeMinutes || currentTimeMinutes <= endTimeMinutes);
   }
   // Ako je vrijeme ograničenja unutar istog dana (npr. 09:00 do 17:00)
   else {
      return (currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes);
   }
}



//---------------
// Nova funkcija za forsiranje inicijalnih naloga nakon zatvaranja svih pozicija
void ForceInitialOrderPlacement() {
    bool allowPendingBuy = true;
    bool allowPendingSell = true;
    int pendingSellOrder, pendingBuyOrder;
    
    // Provjera ograničenja
    if (!TradeLong || SessionTargetStop || StopMinEquity || SpreadStop) {
        allowPendingBuy = false;
    }
    if (!TradeShort || SessionTargetStop || StopMinEquity || SpreadStop) {
        allowPendingSell = false;
    }
    
    // Postavi inicijalne pending naloge
    if(allowPendingSell) {
        pendingSellOrder = OrderSend(Symbol(), OP_SELLSTOP, PendingLots, Bid - PendingSpacing * Point, 3, 0, 0, "New Cycle", MagicNumber, 0, Red);
        if(pendingSellOrder <= 0) {
         //   Print("Error adding initial SELLSTOP after cycle: ", GetLastError());
        }
    }
    
    if(allowPendingBuy) {
        pendingBuyOrder = OrderSend(Symbol(), OP_BUYSTOP, PendingLots, Ask + PendingSpacing * Point, 3, 0, 0, "New Cycle", MagicNumber, 0, Blue);
        if(pendingBuyOrder <= 0) {
          //  Print("Error adding initial BUYSTOP after cycle: ", GetLastError());
        }
    }
    
    initialOrdersPlaced = true;
   // Print("New trading cycle initialized with fresh pending orders");
}



// Funkcija za provjeru je li tržište u "sideways" stanju
bool IsSidewaysMarket() {
    // Ako je filter isključen, uvijek vrati false (kao da nije sideways)
    if(!EnableRangeFilter) return false;
    
    // Ažuriranje range vrijednosti svakih 10 minuta
    if(TimeCurrent() - lastRangeUpdate > 600 || rangeHigh == 0 || rangeLow == 0) {
        CalculateRange();
        lastRangeUpdate = TimeCurrent();
    }
    
    // Trenutna cijena
    double currentPrice = (Ask + Bid) / 2;
    
    // Provjeri je li cijena unutar raspona
    bool insideRange = (currentPrice >= rangeLow && currentPrice <= rangeHigh);
    
    return insideRange;
}

// Funkcija za izračun range vrijednosti
void CalculateRange() {
    double highestHigh = 0;
    double lowestLow = 100000;
    
    // Pronađi najvišu i najnižu cijenu u zadnjih 24 bara na RangeTimeFrame
   // for(int i = 0; i < 24; i++) {
     for(int i = 0; i < 10; i++) {
    
        double high = iHigh(Symbol(), RangeTimeFrame, i);
        double low = iLow(Symbol(), RangeTimeFrame, i);
        
        if(high > highestHigh) highestHigh = high;
        if(low < lowestLow) lowestLow = low;
    }
    
    // Ako je stvarni raspon veći od definiranog, prilagodi ga
    double actualRange = highestHigh - lowestLow;
    double requiredRange = Range * Point * 10; // Pretvaranje pipsa u cijenu (10 = 1 pip za 5-znamenkaste brokere)
    
    if(actualRange <= requiredRange) {
        // Ako je stvarni raspon manji ili jednak traženom, koristi ga
        rangeHigh = highestHigh;
        rangeLow = lowestLow;
    } else {
        // Ako je stvarni raspon veći, centiramo ga oko trenutne cijene
        double currentPrice = (Ask + Bid) / 2;
        rangeHigh = currentPrice + (requiredRange / 2);
        rangeLow = currentPrice - (requiredRange / 2);
    }
    
    // Debug info
    if(EnableRangeFilter) {
        Print("Range izračunat: Low=", rangeLow, " High=", rangeHigh, " (", (rangeHigh-rangeLow)/(Point*10), " pipsa)");
    }
}

// Funkcija za crtanje Range zone na grafikonu
void DrawRangeZone() {
    if(!EnableRangeFilter) return;
    
    // Obriši stare linije
    ObjectDelete("RangeHigh");
    ObjectDelete("RangeLow");
    ObjectDelete("RangeText");
    
    // Nacrtaj gornju granicu
    ObjectCreate("RangeHigh", OBJ_HLINE, 0, 0, rangeHigh);
    ObjectSet("RangeHigh", OBJPROP_COLOR, clrOrange);
    ObjectSet("RangeHigh", OBJPROP_STYLE, STYLE_DASH);
    
    // Nacrtaj donju granicu
    ObjectCreate("RangeLow", OBJ_HLINE, 0, 0, rangeLow);
    ObjectSet("RangeLow", OBJPROP_COLOR, clrOrange);
    ObjectSet("RangeLow", OBJPROP_STYLE, STYLE_DASH);
    
    // Dodaj tekst
    ObjectCreate("RangeText", OBJ_TEXT, 0, Time[0], rangeHigh);
    ObjectSetText("RangeText", "Sideways zone: " + DoubleToStr((rangeHigh-rangeLow)/(Point*10), 1) + " pips", 8, "Arial", clrOrange);
}
//---------------
// Dodajte ovu funkciju prije switch bloka
void CheckAndApplyTrailingProfit() {
    if(!UseTrailingProfit) return; // Ako nije uključen, izađi iz funkcije
    
     currentProfit = BuyProfit2 + SellProfit2;
    
    // Ako je trenutni profit veći od dosadašnjeg maksimuma, ažuriraj
    if(currentProfit > GlobalMaxProfit) {
        GlobalMaxProfit = currentProfit;
        
        // Postavi novu razinu trailing profita
        // Zaokruži na niži višekratnik koraka
        TrailingProfitLevel = MathFloor(GlobalMaxProfit / (TrailingProfitStep * Point)) * TrailingProfitStep * Point;
        
        // Debug ispis ako je potrebno
         Print("Nova razina trailing profita: ", TrailingProfitLevel);
    }
    
    // Ako je profit pao ispod trailing razine, zatvori sve naloge
    if(currentProfit < TrailingProfitLevel && TrailingProfitLevel > 0) {
       Print("Trailing profit aktiviran na razini: ", TrailingProfitLevel, ", trenutni profit: ", currentProfit);
        
        // Zatvori sve aktivne naloge
        CloseOrdersOptimizedByProfit();
        ClosePendingBuyStop();
        ClosePendingSellStop();
        
        // Reset nakon zatvaranja
        GlobalMaxProfit = 0;
        TrailingProfitLevel = 0;
        
        // Dodatni reset varijabli kao kod dostizanja profit targeta
       static bool singleOrderClosed = false;
        lastOrderType = -1;
        initialOrdersPlaced = false;
      static double  lastBuyPrice = 0;
      static double  lastSellPrice = 0;
    }
} 
    
